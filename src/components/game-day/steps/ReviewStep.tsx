import { useState, useEffect, useMemo, useRef } from 'react';
import { useLineup } from '../../../hooks/useLineup';
import { useLineupEditor } from '../../../hooks/useLineupEditor';
import { useRoster } from '../../../hooks/useRoster';
import { useBattingOrder } from '../../../hooks/useBattingOrder';
import { useGameHistory } from '../../../hooks/useGameHistory';
import { DraggableLineupGrid } from '../../lineup/DraggableLineupGrid';
import { FairnessScoreCard } from '../../lineup/FairnessScoreCard';
import { FairnessSummary } from '../../lineup/FairnessSummary';
import type { PlayerFairness } from '../../lineup/FairnessSummary';
import { ValidationPanel } from '../../lineup/ValidationPanel';
import { scoreLineup } from '../../../logic/lineup-scorer';
import { SortableBattingOrder } from '../../batting-order/SortableBattingOrder';
import type { Lineup, Player, Position } from '../../../types/index';
import { POSITIONS, INFIELD_POSITIONS } from '../../../types/index';
import type { GenerateLineupInput } from '../../../logic/lineup-types';
import styles from './ReviewStep.module.css';

function computeFairnessSummary(
  lineup: Lineup,
  innings: number,
  players: Player[],
): PlayerFairness[] {
  const presentPlayers = players.filter(p => p.isPresent);
  const inningNumbers = Array.from({ length: innings }, (_, i) => i + 1);

  return presentPlayers
    .map(player => {
      let infieldInnings = 0;
      let benchInnings = 0;

      for (const inn of inningNumbers) {
        const assignment = lineup[inn];
        if (!assignment) continue;

        const assignedPositions = POSITIONS.filter(
          (pos: Position) => assignment[pos] === player.id,
        );

        if (assignedPositions.length === 0) {
          benchInnings++;
        } else if (
          assignedPositions.some((pos: Position) =>
            (INFIELD_POSITIONS as readonly string[]).includes(pos),
          )
        ) {
          infieldInnings++;
        }
      }

      return {
        playerId: player.id,
        name: player.name,
        infieldInnings,
        benchInnings,
      };
    })
    .sort((a, b) => a.name.localeCompare(b.name));
}

function getPlayerName(playerId: string, players: Player[]): string {
  const player = players.find(p => p.id === playerId);
  return player?.name ?? 'Unknown';
}

interface ReviewStepProps {
  onComplete: () => void;
}

export function ReviewStep({ onComplete }: ReviewStepProps) {
  const {
    generatedLineups,
    selectedLineup,
    innings,
    generate,
    presentPlayers,
    pitcherAssignments,
    catcherAssignments,
    positionBlocks,
  } = useLineup();

  const { players } = useRoster();

  const {
    currentOrder,
    presentPlayers: battingPresentPlayers,
    generate: generateBattingOrder,
  } = useBattingOrder();

  const { history } = useGameHistory();

  const validationInput: GenerateLineupInput = useMemo(() => ({
    presentPlayers,
    innings,
    pitcherAssignments,
    catcherAssignments,
    positionBlocks,
  }), [presentPlayers, innings, pitcherAssignments, catcherAssignments, positionBlocks]);

  const editor = useLineupEditor(selectedLineup, validationInput);

  const lineupScore = useMemo(() => {
    if (!editor.lineup) return null;
    return scoreLineup(editor.lineup, validationInput);
  }, [editor.lineup, validationInput]);

  useEffect(() => {
    editor.setBattingOrder(currentOrder);
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentOrder]);

  const [_hasGeneratedBatting, setHasGeneratedBatting] = useState(currentOrder !== null);
  const [generateError, setGenerateError] = useState('');

  // Auto-generate on mount if no lineups exist
  const hasAutoGenerated = useRef(false);
  useEffect(() => {
    if (hasAutoGenerated.current) return;
    if (generatedLineups.length === 0) {
      hasAutoGenerated.current = true;
      const result = generate();
      if (!result.success && result.errors.length > 0) {
        setGenerateError(result.errors[0]);
      } else if (result.success) {
        // Auto-generate batting order alongside lineup (GEN-04)
        generateBattingOrder();
        setHasGeneratedBatting(true);
      }
    }
  }, [generatedLineups.length, generate, generateBattingOrder]);

  const handleRegenerate = () => {
    setGenerateError('');
    const result = generate();
    if (!result.success && result.errors.length > 0) {
      setGenerateError(result.errors[0]);
    } else if (result.success) {
      // Regenerate batting order with new lineup (GEN-04)
      generateBattingOrder();
      setHasGeneratedBatting(true);
    }
  };

  // Previous batting order from game history (FLOW-05)
  const previousBattingOrder =
    history.length > 0 ? history[history.length - 1].battingOrder : null;

  return (
    <div className={styles.step}>
      <h2 className={styles.heading}>
        Review Lineup
        {editor.hasEdits && (
          <span className={styles.editsBadge}>Edited</span>
        )}
      </h2>

      {/* Regenerate button */}
      <div className={styles.section}>
        <button
          type="button"
          className={styles.regenerateButton}
          onClick={handleRegenerate}
        >
          Regenerate Lineup
        </button>
        {generateError && (
          <p className={styles.generateError}>{generateError}</p>
        )}
      </div>

      {/* Lineup Grid, Fairness, Validation */}
      {editor.lineup && (
        <div className={styles.section}>
          <DraggableLineupGrid
            lineup={editor.lineup}
            innings={innings}
            players={players}
            errors={editor.validationErrors}
            onSwap={editor.swapPositions}
          />
          {lineupScore && <FairnessScoreCard score={lineupScore} />}
          <FairnessSummary
            summary={computeFairnessSummary(editor.lineup, innings, players)}
          />
          <ValidationPanel errors={editor.validationErrors} preErrors={[]} />
        </div>
      )}

      {/* Batting Order section */}
      <div className={styles.section}>
        <h3 className={styles.sectionTitle}>Batting Order</h3>
        {editor.battingOrder && (
          <SortableBattingOrder
            order={editor.battingOrder}
            players={battingPresentPlayers}
            onReorder={editor.reorderBattingOrder}
          />
        )}
        {!editor.battingOrder && (
          <p className={styles.emptyMessage}>
            Batting order will be generated with the lineup.
          </p>
        )}
      </div>

      {/* Previous Batting Order comparison (FLOW-05) */}
      {previousBattingOrder && editor.battingOrder && (
        <div className={styles.section}>
          <p className={styles.comparisonLabel}>
            Last game's batting order for reference
          </p>
          <div className={styles.comparison}>
            <div className={styles.comparisonColumn}>
              <h4 className={styles.comparisonTitle}>Previous Game</h4>
              <ol className={styles.comparisonList}>
                {previousBattingOrder.map((playerId, index) => (
                  <li key={`prev-${index}`}>
                    {getPlayerName(playerId, players)}
                  </li>
                ))}
              </ol>
            </div>
            <div className={styles.comparisonColumn}>
              <h4 className={styles.comparisonTitle}>Current Game</h4>
              <ol className={styles.comparisonList}>
                {editor.battingOrder!.map((playerId, index) => (
                  <li key={`curr-${index}`}>
                    {getPlayerName(playerId, players)}
                  </li>
                ))}
              </ol>
            </div>
          </div>
        </div>
      )}

      <button
        type="button"
        className={styles.nextButton}
        onClick={onComplete}
        disabled={!editor.battingOrder}
      >
        Next
      </button>
    </div>
  );
}
