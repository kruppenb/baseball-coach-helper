---
phase: 16-game-history-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/src/functions/game-history.ts
  - src/hooks/useGameHistory.ts
  - src/types/index.ts
  - src/components/app-shell/AppShell.tsx
autonomous: true
requirements: [HMGT-01, HMGT-02]

must_haves:
  truths:
    - "useGameHistory exposes a deleteGame function that removes an entry from local state and triggers cloud deletion"
    - "DELETE /api/game-history/:id endpoint removes a game history document from Cosmos DB"
    - "History tab appears in the main tab bar labeled 'History' with no badge"
    - "Clicking the History tab shows the HistoryPage component"
  artifacts:
    - path: "api/src/functions/game-history.ts"
      provides: "DELETE endpoint for game history entries"
      contains: "deleteGameHistoryEntry"
    - path: "src/hooks/useGameHistory.ts"
      provides: "deleteGame function with undo support"
      contains: "deleteGame"
    - path: "src/types/index.ts"
      provides: "Updated TabId type including 'history'"
      contains: "history"
    - path: "src/components/app-shell/AppShell.tsx"
      provides: "History tab wired into tab bar and panel rendering"
      contains: "HistoryPage"
  key_links:
    - from: "src/hooks/useGameHistory.ts"
      to: "/api/game-history"
      via: "fetch DELETE call for cloud deletion"
      pattern: "fetch.*DELETE"
    - from: "src/components/app-shell/AppShell.tsx"
      to: "src/components/history/HistoryPage.tsx"
      via: "conditional rendering on activeTab === 'history'"
      pattern: "activeTab.*history"
---

<objective>
Add the data layer for game history deletion (API endpoint + hook function) and wire
the History tab into the main app navigation.

Purpose: Provide the infrastructure for viewing and deleting game history entries,
which Plan 02 will build the full UI on top of.

Output: Working DELETE endpoint, useGameHistory.deleteGame function, and History tab
visible in the app tab bar rendering the existing HistoryPage.
</objective>

<execution_context>
@C:/Users/nicho/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicho/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-game-history-management/16-CONTEXT.md

@api/src/functions/game-history.ts
@api/src/lib/cosmos.ts
@api/src/lib/auth.ts
@api/src/lib/validation.ts
@src/hooks/useGameHistory.ts
@src/sync/useCloudStorage.ts
@src/sync/sync-engine.ts
@src/types/index.ts
@src/components/app-shell/AppShell.tsx
@src/components/app-shell/TabBar.tsx
@src/components/history/HistoryPage.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DELETE API endpoint and useGameHistory.deleteGame with undo support</name>
  <files>
    api/src/functions/game-history.ts
    src/hooks/useGameHistory.ts
  </files>
  <action>
**API — api/src/functions/game-history.ts:**

Add a `deleteGameHistoryEntry` handler for `DELETE /api/game-history/{entryId}`:
1. Parse client principal (401 if missing)
2. Build the Cosmos document ID: `game-${principal.userId}-${entryId}` (same pattern as PUT)
3. Delete from Cosmos via `container.item(docId, principal.userId).delete()`
4. Return 204 on success, 404 if item not found (catch 404 status from Cosmos), 500 on other errors
5. Register the route: `app.http('deleteGameHistoryEntry', { methods: ['DELETE'], authLevel: 'anonymous', route: 'game-history/{entryId}', handler: deleteGameHistoryEntry })`

**Hook — src/hooks/useGameHistory.ts:**

Add `deleteGame` function to the hook return value:
1. Accept `entryId: string` parameter
2. Remove the entry from local state: `setHistory((prev) => prev.filter(e => e.id !== entryId))`
3. Also update `localStorage` key `gameHistory:lastSyncedCount` — decrement by 1 (read current value, subtract 1, write back) since the collection sync mode tracks array length. Clamp to 0 minimum.
4. For cloud deletion: get the `user` from `useAuth()` (import and call at hook top level). If `user` is truthy, fire `fetch(\`/api/game-history/${entryId}\`, { method: 'DELETE' })` as a fire-and-forget (no await needed in the callback, but use `.catch(() => {})` to swallow network errors gracefully).
5. Return the removed entry (find it before filtering) so the caller can implement undo.

Add `undoDelete` function:
1. Accept `entry: GameHistoryEntry` and `originalIndex: number` parameters
2. Re-insert the entry into local state at the original position: `setHistory((prev) => { const next = [...prev]; next.splice(originalIndex, 0, entry); return next; })`
3. Increment `gameHistory:lastSyncedCount` by 1
4. If `user` is truthy, call `saveGame`-style PUT to re-push the entry to cloud (use existing collection push pattern — `fetch(config.endpoint, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ data: entry }) })`)

Import `useAuth` from `../auth/useAuth`.

Export both `deleteGame` and `undoDelete` from the hook return object.
  </action>
  <verify>
- `cd api && npx tsc --noEmit` passes with no errors
- `npm run build` at root passes
- Inspect `api/src/functions/game-history.ts` and confirm the DELETE route is registered
- Inspect `src/hooks/useGameHistory.ts` and confirm deleteGame and undoDelete are exported
  </verify>
  <done>
DELETE /api/game-history/{entryId} endpoint exists and compiles. useGameHistory exposes deleteGame (removes from local + fires cloud delete) and undoDelete (re-inserts locally + re-pushes to cloud). Both handle authenticated and unauthenticated users gracefully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add History tab to AppShell navigation</name>
  <files>
    src/types/index.ts
    src/components/app-shell/AppShell.tsx
  </files>
  <action>
**Types — src/types/index.ts:**

Update `TabId` union type to include `'history'`:
```
export type TabId = 'game-day' | 'history' | 'settings';
```

**AppShell — src/components/app-shell/AppShell.tsx:**

1. Import `HistoryPage` from `'../history/HistoryPage'`
2. Add the history tab to the `tabs` array, positioned between Game Day and Settings:
   ```
   const tabs = [
     { id: 'game-day', label: 'Game Day' },
     { id: 'history', label: 'History' },
     { id: 'settings', label: 'Settings' },
   ];
   ```
   Per user decision: tab labeled "History" with no badge or game count.

3. Add a new conditional panel block for the history tab inside `<main>`, between the game-day and settings panels:
   ```jsx
   {activeTab === 'history' && (
     <div
       role="tabpanel"
       id="panel-history"
       aria-labelledby="tab-history"
     >
       <HistoryPage />
     </div>
   )}
   ```

No other changes needed — the TabBar component already works generically with the tabs array and handles keyboard navigation.
  </action>
  <verify>
- `npm run build` at root passes with no TypeScript errors
- Run `npm run dev` and confirm three tabs appear: Game Day, History, Settings
- Clicking History tab shows the existing HistoryPage content
  </verify>
  <done>
Three tabs visible in the app: Game Day, History, Settings. History tab renders HistoryPage. Tab keyboard navigation works for all three tabs. No TypeScript errors.
  </done>
</task>

</tasks>

<verification>
1. `cd api && npx tsc --noEmit` — API compiles clean
2. `npm run build` (root) — frontend builds without errors
3. Three tabs visible in running app: Game Day, History, Settings
4. History tab shows the existing game history list (or empty state)
5. deleteGame and undoDelete are exported from useGameHistory hook
</verification>

<success_criteria>
- DELETE /api/game-history/{entryId} endpoint registered and compiles
- useGameHistory.deleteGame removes entry from local state and fires cloud DELETE
- useGameHistory.undoDelete re-inserts entry and re-pushes to cloud
- History tab appears in tab bar between Game Day and Settings
- Clicking History tab renders HistoryPage component
- All TypeScript compiles clean (API and frontend)
</success_criteria>

<output>
After completion, create `.planning/phases/16-game-history-management/16-01-SUMMARY.md`
</output>
