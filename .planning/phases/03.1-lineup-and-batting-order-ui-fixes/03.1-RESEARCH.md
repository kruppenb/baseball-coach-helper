# Phase 03.1: Lineup and Batting Order UI Fixes - Research

**Researched:** 2026-02-10
**Domain:** CSS/UI fixes for existing React components (CSS Modules, mobile layout)
**Confidence:** HIGH

## Summary

This phase addresses four UI issues identified during Phase 3 UAT and Phase 2 out-of-scope reports. All four issues are CSS and presentational logic changes to existing components -- no new libraries, hooks, or architecture are needed. The existing codebase uses CSS Modules with CSS custom properties defined in `src/styles/tokens.css`, React 19, and Vite 7. All affected components are already built and tested.

The four issues are: (1) remove band badges from BattingOrderList, (2) fix visually cut-off lineup option cards, (3) make lineup option button names meaningful to coaches, and (4) add per-player infield innings and bench innings counts to the lineup grid as a fairness summary row. Issue 1 is pure deletion. Issue 2 is a CSS-only fix. Issue 3 requires small presentational logic changes. Issue 4 requires computing summary data from the existing Lineup data structure and rendering a new summary row/section.

**Primary recommendation:** These are four independent, small-scope fixes that can each be implemented by modifying existing files (no new components needed). All computation data is already available in the component props/parent state.

## Standard Stack

### Core (already in use -- no changes)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| React | ^19.2.0 | UI framework | Already in use |
| Vite | ^7.3.1 | Build tool | Already in use |
| TypeScript | ~5.9.3 | Type safety | Already in use |
| CSS Modules | (built-in to Vite) | Scoped component styles | Project convention |
| Vitest | ^4.0.18 | Testing | Already in use |

### Supporting
No new libraries needed. All fixes use existing project infrastructure.

### Alternatives Considered
None. This phase modifies existing code only.

## Architecture Patterns

### Existing Project Structure (relevant files only)
```
src/
├── components/
│   ├── batting-order/
│   │   ├── BattingOrderList.tsx        # ISSUE 1: Remove band badges
│   │   ├── BattingOrderList.module.css # ISSUE 1: Remove band styles
│   │   ├── BattingOrderSection.tsx     # No changes needed
│   │   └── BattingOrderSection.module.css
│   └── lineup/
│       ├── LineupOptions.tsx           # ISSUE 2 + 3: Fix cards
│       ├── LineupOptions.module.css    # ISSUE 2: Fix card overflow
│       ├── LineupGrid.tsx              # ISSUE 4: Add fairness summary
│       ├── LineupGrid.module.css       # ISSUE 4: Style summary row
│       ├── LineupPage.tsx              # Parent container (may need minor changes)
│       └── LineupPage.module.css
├── logic/
│   ├── batting-order.ts               # Contains getBand -- import can be removed
│   └── lineup-generator.ts            # Contains generation logic (read-only for Issue 3)
├── types/
│   └── index.ts                       # POSITIONS, INFIELD_POSITIONS constants
└── styles/
    └── tokens.css                     # CSS custom properties
```

### Pattern: Pure Presentational Components
**What:** Components receive all data via props, contain no hooks or side effects.
**Applies to:** BattingOrderList, LineupOptions, LineupGrid, ValidationPanel.
**Constraint:** These components MUST remain pure presentational. Any data computation happens in parent components or hooks and is passed down as props.

### Pattern: CSS Modules with Design Tokens
**What:** Each component has a co-located `.module.css` file. All colors, spacing, and typography reference CSS custom properties from `tokens.css`.
**Constraint:** Do NOT use inline styles for colors/spacing. Do NOT hardcode color values -- use existing tokens or add new tokens to `tokens.css` if needed.

### Anti-Patterns to Avoid
- **Adding hooks to presentational components:** BattingOrderList, LineupGrid, LineupOptions must remain hook-free. Compute data in parent/hook layer.
- **Hardcoding colors:** Always use CSS custom properties from tokens.css. The existing code has a few hardcoded hex values (#d1e7dd, #fff3cd, etc.) which is acceptable only for one-off semantic colors that don't warrant a token.
- **Breaking existing component interfaces:** Do not change prop types unless necessary; removing unused props (like band-related data) is fine when removing features.

## Issue Analysis

### Issue 1: Remove Band Badges from BattingOrderList

**Current state:**
- `BattingOrderList.tsx` imports `getBand` from `../../logic/batting-order`
- Renders a `<span>` with class `bandLabel` + `top`/`middle`/`bottom` for each player
- Uses a `bandStyleMap` record to look up CSS class per band
- CSS has `.bandLabel`, `.top`, `.middle`, `.bottom` classes with colored backgrounds

**What to change:**
- Remove `getBand` import
- Remove `bandStyleMap` constant
- Remove `totalPlayers` computation
- Remove the `<span className={bandLabel}>` element from the render
- Remove `.bandLabel`, `.top`, `.middle`, `.bottom` CSS classes
- The `BattingBand` type in `types/index.ts` should be KEPT -- it is used by `batting-order.ts` for the fairness algorithm which still needs bands internally

**Impact:** Pure deletion. No new code. Component interface (props) unchanged.

### Issue 2: Lineup Option Cards Visually Cut Off

**Current state:**
- `.cardContainer` uses `display: flex` with `overflow-x: auto` and `scroll-snap-type: x mandatory`
- Cards are `width: 200px` with `flex: 0 0 auto`
- The container is inside a `.section` div that has `border-top` and `padding-top`
- The `.options` parent has `padding: var(--space-md) 0`
- AppShell `.content` has `overflow-y: auto` and `padding: var(--space-lg)`

**Root cause analysis:**
- The horizontal scroll container works but there is no visual indicator that more cards exist to the right
- Cards at the right edge get clipped by the parent's padding/overflow
- On a 600px max-width shell with left padding, 3x200px cards (600px) exceed visible width

**What to change:**
- Add right padding inside `.cardContainer` so the last card has breathing room: `padding-right: var(--space-md)` or use `scroll-padding`
- Alternatively, make cards responsive: instead of fixed `width: 200px`, use `min-width: 200px` with a percentage-based width that fits the container
- Best approach: Make the card container a vertical stack on mobile (3 cards stacked) since the app has a 600px max-width anyway. Cards would be full-width and show all content. This eliminates the horizontal scroll problem entirely.

**Recommended approach:** Switch from horizontal scroll to vertical stack. At max-width 600px, horizontal scrolling with 3 cards is a poor UX on phones. Vertical stacking ensures all options are visible without scrolling.

### Issue 3: Lineup Option Button Names Not Meaningful

**Current state:**
- Each card shows "Option 1", "Option 2", "Option 3" as the title
- Below that, a `benchSummary` shows `Inn N: PlayerA, PlayerB` for each inning
- The bench summary IS the differentiating information, but it is secondary/muted text

**Root cause:** "Option 1/2/3" tells the coach nothing about what makes that lineup different. The bench rotation pattern IS the key differentiator (which kids sit out which innings) but it is buried.

**What to change -- make names meaningful:**
- Replace "Option N" with a descriptive label based on the key differentiator
- Best approach: Summarize the bench pattern prominently. E.g., title becomes a summary like "Option 1" with a subtitle showing a concise fairness metric
- Add a quick fairness stat per option: e.g., infield innings distribution, or which players bench which innings shown more prominently
- Simpler alternative: Keep "Option N" but add a 1-line summary like "Bench: Alex(1,4), Sam(2,5), Pat(3)" showing who sits which innings -- this is what coaches actually scan for

**Recommended approach:** Keep "Option N" as card title for simplicity. Replace the verbose per-inning bench list with a compact per-player bench summary: show each benched player's name with their bench inning numbers in parentheses. E.g., "Alex (Inn 1, 4) / Sam (Inn 2, 5)". This lets coaches quickly see "who sits when" which is the primary differentiator between options.

### Issue 4: Missing Infield Innings Count (Fairness Summary)

**Current state:**
- `LineupGrid` shows positions x innings grid plus a bench row
- No per-player summary exists
- The data is already in the `lineup` prop (Lineup type = Record<number, InningAssignment>)
- `INFIELD_POSITIONS` is already exported from types/index: `['P', 'C', '1B', '2B', '3B', 'SS']`

**What to compute:**
For each present player, across all innings in the selected lineup:
- **Infield innings:** Count of innings where player is in P, C, 1B, 2B, 3B, or SS
- **Bench innings:** Count of innings where player is not assigned to any position

**Where to compute:**
- Option A: Compute in `LineupGrid` component itself (it has `lineup`, `innings`, `players` props)
- Option B: Compute in parent `LineupPage` or in `useLineup` hook and pass as prop
- Since LineupGrid is a pure presentational component, computing derived data from existing props is acceptable (it's a pure function of props, not a side effect). This is the simpler path.

**How to display:**
- Add a fairness summary section below the grid (or as additional rows in the grid)
- Show a compact table/list: `Player Name | Infield: N | Bench: N`
- Use color coding to flag potential issues (e.g., if a player has 0 infield innings, highlight in warning color)

**Recommended approach:** Add a "Player Summary" section below the LineupGrid (could be a separate presentational component or a section within LineupGrid). Render a simple list: each player's name, their infield inning count, and their bench inning count. The computation is straightforward -- iterate over all innings, check if player ID appears in any INFIELD_POSITIONS assignment, count bench as innings where they appear in no position.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Horizontal scroll indicators | Custom scroll arrows/indicators | Vertical card stack layout | At 600px max-width, vertical stacking is simpler and removes the problem entirely |
| Player stats computation | Complex aggregation library | Simple loop over Lineup data | Data structure is small (9-13 players x 5-6 innings). A simple `for` loop is fine. |

**Key insight:** All four issues are small-scope UI changes. There is no need for new utilities, libraries, or abstractions. The existing data structures already contain all needed information.

## Common Pitfalls

### Pitfall 1: Breaking BattingOrderList Props Interface
**What goes wrong:** Removing band badges might tempt adding new props (like "last game position") that are deferred to Phase 4.
**Why it happens:** Scope creep from the user's mention of "where did they bat last game."
**How to avoid:** Issue 1 is DELETION ONLY. Do not add any new features to BattingOrderList. "Last game batting position" is explicitly deferred to Phase 4 (requires history system).
**Warning signs:** Any new props being added to BattingOrderListProps.

### Pitfall 2: Horizontal Scroll Complexity
**What goes wrong:** Trying to fix horizontal scroll with complex CSS (scroll-snap, padding tricks, indicator overlays) when vertical stacking solves it cleanly.
**Why it happens:** Anchoring on the existing horizontal layout.
**How to avoid:** Switch to vertical card layout. At max-width 600px, this is the simpler and better UX.
**Warning signs:** Adding more than 5 lines of CSS to fix the card container.

### Pitfall 3: Overcomplicating Lineup Option Names
**What goes wrong:** Trying to generate clever natural-language descriptions of lineup differences.
**Why it happens:** Overthinking what coaches need.
**How to avoid:** Coaches just need to see "who sits when." A compact bench summary per player is sufficient.
**Warning signs:** Complex string-building logic, NLP-like description generation.

### Pitfall 4: Putting Computation in Presentational Components via Hooks
**What goes wrong:** Adding `useMemo` or other hooks to LineupGrid/LineupOptions to compute derived data.
**Why it happens:** Wanting to add computed data close to where it renders.
**How to avoid:** Computing derived data from existing props in the render body (pure function of props) is fine and does NOT require hooks. A simple function call in the component body works. Only add hooks if computation is expensive and needs memoization (not the case here -- small data sets).
**Warning signs:** Adding `import { useMemo } from 'react'` to a previously hook-free component.

### Pitfall 5: Fairness Summary as a Separate Component with Its Own Data Fetching
**What goes wrong:** Creating a FairnessSummary component that independently fetches lineup data via useLineup.
**Why it happens:** Component isolation instinct.
**How to avoid:** The parent already passes `lineup`, `innings`, and `players` as props. Compute within the receiving component or create a small helper function. If extracting to a new component, pass the computed data as props.
**Warning signs:** New component importing hooks.

## Code Examples

### Issue 1: BattingOrderList After Removing Bands
```typescript
// BattingOrderList.tsx - AFTER (simplified)
import type { Player } from '../../types/index';
import styles from './BattingOrderList.module.css';

interface BattingOrderListProps {
  order: string[];
  players: Player[];
}

export function BattingOrderList({ order, players }: BattingOrderListProps) {
  const playerMap = new Map(players.map((p) => [p.id, p]));

  return (
    <ol className={styles.list}>
      {order.map((playerId, index) => {
        const player = playerMap.get(playerId);
        const name = player?.name ?? 'Unknown';

        return (
          <li key={playerId} className={styles.item}>
            <span className={styles.position}>{index + 1}</span>
            <span className={styles.name}>{name}</span>
          </li>
        );
      })}
    </ol>
  );
}
```

### Issue 2: Vertical Card Layout for LineupOptions
```css
/* LineupOptions.module.css - cardContainer changed to vertical */
.cardContainer {
  display: flex;
  flex-direction: column;
  gap: var(--space-md);
}

.card {
  width: 100%;
  padding: var(--space-md);
  border: 2px solid var(--color-border);
  border-radius: var(--radius-md);
  background: white;
  cursor: pointer;
  text-align: left;
  font-family: inherit;
  font-size: inherit;
}
```

### Issue 3: Compact Bench Summary for LineupOptions
```typescript
// Compact bench summary: "Alex (1, 4), Sam (2, 5), Pat (3)"
function getCompactBenchSummary(lineup: Lineup, innings: number, players: Player[]): string {
  const benchInnings: Record<string, number[]> = {};

  for (let inn = 1; inn <= innings; inn++) {
    const assignment = lineup[inn];
    if (!assignment) continue;
    const playingIds = new Set(POSITIONS.map((pos: Position) => assignment[pos]));
    for (const p of players) {
      if (p.isPresent && !playingIds.has(p.id)) {
        if (!benchInnings[p.id]) benchInnings[p.id] = [];
        benchInnings[p.id].push(inn);
      }
    }
  }

  return Object.entries(benchInnings)
    .map(([playerId, innings]) => {
      const player = players.find(p => p.id === playerId);
      const name = player?.name ?? 'Unknown';
      return `${name} (${innings.join(', ')})`;
    })
    .join(', ');
}
```

### Issue 4: Per-Player Fairness Computation
```typescript
// Computing infield and bench counts from a Lineup
interface PlayerFairnessSummary {
  playerId: string;
  name: string;
  infieldInnings: number;
  benchInnings: number;
}

function computeFairnessSummary(
  lineup: Lineup,
  innings: number,
  players: Player[],
): PlayerFairnessSummary[] {
  return players
    .filter(p => p.isPresent)
    .map(player => {
      let infieldInnings = 0;
      let benchInnings = 0;

      for (let inn = 1; inn <= innings; inn++) {
        const assignment = lineup[inn];
        if (!assignment) continue;

        const isInfield = INFIELD_POSITIONS.some(pos => assignment[pos] === player.id);
        const isPlaying = POSITIONS.some(pos => assignment[pos] === player.id);

        if (isInfield) infieldInnings++;
        if (!isPlaying) benchInnings++;
      }

      return {
        playerId: player.id,
        name: player.name,
        infieldInnings,
        benchInnings,
      };
    });
}
```

## State of the Art

No state-of-the-art changes relevant. This phase uses the same stack as Phases 1-3 with no new libraries or patterns.

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Band badges in batting order | Simple numbered list (no badges) | Phase 03.1 | Removes confusing UI element |
| Horizontal card scroll | Vertical card stack | Phase 03.1 | All options visible without scrolling |
| "Option 1/2/3" labels | Compact bench summary per option | Phase 03.1 | Coach can distinguish lineups at a glance |
| No fairness summary | Infield + bench count per player | Phase 03.1 | Coach can validate fairness visually |

## Open Questions

1. **Fairness summary placement**
   - What we know: LineupGrid renders a grid with bench row. Summary data can be computed from existing props.
   - What's unclear: Should the summary be appended as extra rows to the grid, or rendered as a separate section below the grid?
   - Recommendation: Render as a separate section below the grid. The grid is already complex (positions x innings). A summary table below with "Player | Infield | Bench" columns is cleaner and more scannable.

2. **Fairness summary as new component or within LineupGrid?**
   - What we know: LineupGrid is pure presentational. Adding a summary section inside it keeps things co-located.
   - What's unclear: Whether this makes LineupGrid too large or if extraction is warranted.
   - Recommendation: Start with a separate small presentational component (`FairnessSummary`) rendered by `LineupPage` alongside `LineupGrid`. This follows the existing pattern of LineupPage composing multiple presentational components. The computation helper function can live as a plain function in the component file or in a shared utility.

3. **How verbose should bench summary on option cards be?**
   - What we know: Current bench summary lists per-inning bench players. User wants more meaningful differentiation.
   - What's unclear: Exact format the coach prefers.
   - Recommendation: Use per-player format "Alex (1, 4), Sam (2, 5)" as default. This is more scannable than the current per-inning format. Can be refined in future phases based on feedback.

## Sources

### Primary (HIGH confidence)
- **Codebase inspection** (direct file reads):
  - `src/components/batting-order/BattingOrderList.tsx` -- current band badge implementation
  - `src/components/batting-order/BattingOrderList.module.css` -- current band styles
  - `src/components/lineup/LineupOptions.tsx` -- current card rendering and bench summary logic
  - `src/components/lineup/LineupOptions.module.css` -- current horizontal scroll layout (200px cards)
  - `src/components/lineup/LineupGrid.tsx` -- current grid rendering
  - `src/components/lineup/LineupGrid.module.css` -- current grid styles
  - `src/components/lineup/LineupPage.tsx` -- parent container composition pattern
  - `src/types/index.ts` -- POSITIONS, INFIELD_POSITIONS constants
  - `src/styles/tokens.css` -- design token definitions
  - `src/components/app-shell/AppShell.module.css` -- 600px max-width constraint
  - `.planning/phases/03-batting-order/03-UAT.md` -- original issue reports

### Secondary (MEDIUM confidence)
- None needed -- all findings are from direct codebase inspection

### Tertiary (LOW confidence)
- None

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- no new libraries, using existing project stack
- Architecture: HIGH -- modifying existing components following established patterns
- Pitfalls: HIGH -- issues are clearly defined from UAT, fixes are straightforward
- Code examples: MEDIUM -- examples are illustrative patterns, exact implementation may vary slightly

**Research date:** 2026-02-10
**Valid until:** 2026-03-10 (30 days -- stable, no external dependency changes)
