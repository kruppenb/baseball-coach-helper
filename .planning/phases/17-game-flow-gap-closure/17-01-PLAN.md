---
phase: 17-game-flow-gap-closure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/app-shell/AppShell.tsx
  - src/components/game-day/GameDayDesktop.tsx
  - src/components/game-day/GameDayStepper.tsx
  - src/components/game-day/steps/PrintStep.tsx
  - src/hooks/useGameHistory.ts
  - src/types/index.ts
  - src/logic/game-history.ts
autonomous: true
requirements: [GFLW-03, GFLW-04]

must_haves:
  truths:
    - "After DnD position swaps on desktop, printing saves the edited lineup (not the original) to game history"
    - "After DnD batting order reordering on desktop, printing saves the reordered order (not the original) to game history"
    - "No file contains a finalizeGame export, a Finalize Game button, or references to a Finalize step"
    - "HistoryPage empty-state text references the print-as-save flow"
  artifacts:
    - path: "src/components/app-shell/AppShell.tsx"
      provides: "Save flow using display lineup/order refs instead of raw hook values"
      contains: "displayLineupRef|displayBattingOrderRef"
    - path: "src/components/game-day/GameDayDesktop.tsx"
      provides: "Callback reporting edited lineup and batting order to AppShell"
      contains: "onDisplayStateChange"
    - path: "src/hooks/useGameHistory.ts"
      provides: "Clean hook with no finalizeGame export"
      must_not_contain: "finalizeGame"
  key_links:
    - from: "src/components/game-day/GameDayDesktop.tsx"
      to: "src/components/app-shell/AppShell.tsx"
      via: "onDisplayStateChange callback reporting editor.lineup and editor.battingOrder"
      pattern: "onDisplayStateChange"
    - from: "src/components/app-shell/AppShell.tsx"
      to: "src/hooks/useGameHistory.ts"
      via: "saveGame called with displayLineupRef.current and displayBattingOrderRef.current"
      pattern: "displayLineupRef\\.current|displayBattingOrderRef\\.current"
---

<objective>
Persist DnD-edited lineup and batting order to game history on print, and remove dead Finalize code.

Purpose: On desktop, drag-and-drop position swaps and batting order reordering modify local editor state (useLineupEditor) that never flows back to AppShell's save call. The save currently uses the original generated values from useLineup/useBattingOrder hooks. This plan wires the edited values from GameDayDesktop back to AppShell so saveGame receives the actual displayed data. It also removes the deprecated finalizeGame function and stale JSDoc references.

Output: All six files updated so DnD edits persist and no Finalize references remain.
</objective>

<execution_context>
@C:/Users/nicho/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicho/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/components/app-shell/AppShell.tsx
@src/components/game-day/GameDayDesktop.tsx
@src/components/game-day/GameDayStepper.tsx
@src/components/game-day/steps/PrintStep.tsx
@src/hooks/useLineupEditor.ts
@src/hooks/useGameHistory.ts
@src/hooks/useLineup.ts
@src/hooks/useBattingOrder.ts
@src/types/index.ts
@src/logic/game-history.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire edited lineup and batting order from desktop/stepper to AppShell save flow</name>
  <files>
    src/components/app-shell/AppShell.tsx
    src/components/game-day/GameDayDesktop.tsx
    src/components/game-day/GameDayStepper.tsx
    src/components/game-day/steps/PrintStep.tsx
  </files>
  <action>
**The problem:** AppShell.handleGameLabelConfirm (line 89-100) calls `saveGame(selectedLineup, currentOrder, ...)` where `selectedLineup` comes from `useLineup()` (the original generated lineup stored in cloud storage) and `currentOrder` comes from `useBattingOrder()` (the original generated batting order). On desktop, the user edits positions via DnD (swapPositions in useLineupEditor) and reorders batting order (reorderBattingOrder in useLineupEditor), but these edits live only in GameDayDesktop's `editor.lineup` and `editor.battingOrder` state. The save call never sees the edits.

**The fix — lift display state via callback + refs:**

1. **AppShell.tsx:**
   - Add two refs: `displayLineupRef = useRef<Lineup | null>(null)` and `displayBattingOrderRef = useRef<string[] | null>(null)`.
   - Create a callback `handleDisplayStateChange(lineup: Lineup | null, battingOrder: string[] | null)` that updates both refs.
   - Pass `onDisplayStateChange={handleDisplayStateChange}` to both `GameDayDesktop` and `GameDayStepper`.
   - In `handleGameLabelConfirm`: use `displayLineupRef.current ?? selectedLineup` and `displayBattingOrderRef.current ?? currentOrder` as the lineup and batting order arguments to `saveGame`. Same pattern in `handleSaveAndNew`.
   - In `handleDontSave` and `performReset`: clear refs (`displayLineupRef.current = null; displayBattingOrderRef.current = null`).

2. **GameDayDesktop.tsx:**
   - Accept new prop `onDisplayStateChange: (lineup: Lineup | null, battingOrder: string[] | null) => void`.
   - Add a `useEffect` that calls `onDisplayStateChange(editor.lineup, editor.battingOrder)` whenever `editor.lineup` or `editor.battingOrder` changes. This reports the latest edited values up to AppShell.
   - On unmount (cleanup return in useEffect), call `onDisplayStateChange(null, null)` to clear stale refs when switching tabs.

3. **GameDayStepper.tsx:**
   - Accept new prop `onDisplayStateChange: (lineup: Lineup | null, battingOrder: string[] | null) => void`.
   - The stepper does NOT use useLineupEditor (no DnD on mobile), so this is pass-through only for interface consistency. The stepper's PrintStep reads `selectedLineup` and `currentOrder` directly from hooks, which are the same values AppShell uses for save — no gap on mobile.
   - However, for interface consistency so AppShell can pass the prop without conditional logic, accept the prop but do not call it. This is fine because mobile has no DnD editing — the generated values ARE the display values.

4. **PrintStep.tsx:** No changes needed. It already renders `selectedLineup`/`currentOrder` from hooks (which on mobile are correct since there's no editor).

**Key constraint:** Use refs (not state) in AppShell for the display values to avoid triggering re-renders on every DnD drag. The values only need to be read at save time.

**Import:** Add `import type { Lineup } from '../../types/index';` to AppShell.tsx if not already imported.
  </action>
  <verify>
Run `cd C:/repos/baseball-coach-helper && npx tsc --noEmit` — must pass with no type errors.
Run `npm run build` — must succeed.
Grep for `displayLineupRef` in AppShell.tsx to confirm wiring exists.
Grep for `onDisplayStateChange` in GameDayDesktop.tsx to confirm callback is called.
  </verify>
  <done>
AppShell's save flow reads from displayLineupRef/displayBattingOrderRef (populated by GameDayDesktop's editor state). DnD position swaps and batting order reordering on desktop will now persist to game history when printing. Mobile flow is unchanged (refs remain null, fallback to hook values).
  </done>
</task>

<task type="auto">
  <name>Task 2: Remove dead Finalize code and stale JSDoc references</name>
  <files>
    src/hooks/useGameHistory.ts
    src/types/index.ts
    src/logic/game-history.ts
  </files>
  <action>
1. **useGameHistory.ts:**
   - Delete the `finalizeGame` useCallback (lines 58-69) entirely.
   - Remove `finalizeGame` from the return object (line 140).
   - This is safe because: (a) Phase 15-01 already removed the only UI caller (ReviewStep's Finalize button), (b) saveGame is the replacement, (c) no other file imports finalizeGame.

2. **src/types/index.ts line 84:**
   - Change the JSDoc comment from `/** A complete snapshot of a finalized game */` to `/** A complete snapshot of a saved game */`.

3. **src/logic/game-history.ts line 5:**
   - Change the JSDoc comment from `Create a game history entry from a finalized game's data.` to `Create a game history entry from a saved game's data.`

4. **src/components/history/HistoryPage.tsx line 156:**
   - The comment says "If there's a pending undo, finalize it (make previous delete permanent)". The word "finalize" here means "make permanent" in the context of the undo/delete flow, NOT the Finalize Game step. However, to satisfy the requirement that no file references a "Finalize step", change the comment to: "If there's a pending undo, commit it (make previous delete permanent)". This is a cosmetic change for clarity — the logic is unchanged.

**Verification that no callers remain:** Run a grep for `finalizeGame` across the entire src/ directory after removal. Only the removed lines should have existed.
  </action>
  <verify>
Run `cd C:/repos/baseball-coach-helper && npx tsc --noEmit` — must pass.
Grep for `finalizeGame` in src/ — must return zero matches.
Grep for `finalized game` in src/ — must return zero matches.
Grep for `Finalize` (capital F) in src/ — must return zero matches.
  </verify>
  <done>
No file in src/ contains finalizeGame, "Finalize Game", "Finalize step", or "finalized game". All JSDoc comments updated to use "saved game" terminology. The deprecated wrapper is fully removed.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (both from root and api/)
2. `npm run build` succeeds
3. `grep -r "finalizeGame" src/` returns nothing
4. `grep -r "finalized game" src/` returns nothing (case insensitive)
5. `grep -r "Finalize" src/` returns nothing (case sensitive, capital F)
6. `grep -r "displayLineupRef" src/components/app-shell/AppShell.tsx` confirms ref wiring
7. `grep -r "onDisplayStateChange" src/components/game-day/GameDayDesktop.tsx` confirms callback
</verification>

<success_criteria>
- DnD-edited position swaps on desktop persist to game history when printing (saveGame receives editor.lineup, not selectedLineup)
- DnD-reordered batting order on desktop persists to game history when printing (saveGame receives editor.battingOrder, not currentOrder)
- No file in the repository contains finalizeGame, "Finalize Game" button, or references to a Finalize step
- HistoryPage empty-state text correctly references print-as-save flow (already correct: "Print a dugout card to save your first game")
- Build and type-check both pass cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/17-game-flow-gap-closure/17-01-SUMMARY.md`
</output>
