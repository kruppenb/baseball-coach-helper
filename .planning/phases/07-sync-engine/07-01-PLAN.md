---
phase: 07-sync-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/sync/sync-types.ts
  - src/sync/sync-engine.ts
  - src/sync/useOnlineStatus.ts
  - src/sync/SyncContext.tsx
  - src/sync/useCloudStorage.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "useCloudStorage returns [T, setter] with identical signature to useLocalStorage"
    - "Unauthenticated users get pure localStorage passthrough with zero network activity"
    - "Writes go to localStorage immediately and schedule a debounced push to cloud"
    - "On mount for authenticated users, cloud data is pulled once and hydrates localStorage"
    - "SyncContext aggregates per-key sync status into a single worst-case status value"
    - "Online/offline events are tracked and trigger retry of pending pushes on reconnect"
  artifacts:
    - path: "src/sync/sync-types.ts"
      provides: "SyncStatus type, SyncKeyConfig, API response shapes"
      contains: "SyncStatus"
    - path: "src/sync/sync-engine.ts"
      provides: "pushToCloud, pullFromCloud, debouncedPush functions"
      exports: ["pushToCloud", "pullFromCloud", "debouncedPush"]
    - path: "src/sync/useOnlineStatus.ts"
      provides: "Hook tracking navigator.onLine with event listeners"
      exports: ["useOnlineStatus"]
    - path: "src/sync/SyncContext.tsx"
      provides: "SyncProvider component and useSyncContext hook"
      exports: ["SyncProvider", "useSyncContext"]
    - path: "src/sync/useCloudStorage.ts"
      provides: "Drop-in replacement hook for useLocalStorage with cloud sync"
      exports: ["useCloudStorage"]
  key_links:
    - from: "src/sync/useCloudStorage.ts"
      to: "src/hooks/useLocalStorage.ts"
      via: "import and delegation"
      pattern: "useLocalStorage"
    - from: "src/sync/useCloudStorage.ts"
      to: "src/sync/sync-engine.ts"
      via: "push/pull function calls"
      pattern: "pushToCloud|pullFromCloud|debouncedPush"
    - from: "src/sync/useCloudStorage.ts"
      to: "src/sync/SyncContext.tsx"
      via: "useSyncContext for status reporting"
      pattern: "useSyncContext"
    - from: "src/sync/SyncContext.tsx"
      to: "src/sync/useOnlineStatus.ts"
      via: "online detection for retry trigger"
      pattern: "useOnlineStatus"
---

<objective>
Build the complete sync engine infrastructure: types, core push/pull logic, online detection, React context for aggregated status, and the useCloudStorage hook that domain hooks will consume.

Purpose: This is the foundation of offline-first cloud sync. Every subsequent integration (hook migration, UI indicator) depends on these modules existing and working correctly.
Output: Five new files in src/sync/ providing a fully functional sync engine ready for integration.
</objective>

<execution_context>
@C:/Users/nicho/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicho/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-sync-engine/07-RESEARCH.md

@src/hooks/useLocalStorage.ts
@src/auth/AuthContext.tsx
@src/auth/useAuth.ts
@src/auth/types.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sync types, sync engine module, and online status hook</name>
  <files>
    src/sync/sync-types.ts
    src/sync/sync-engine.ts
    src/sync/useOnlineStatus.ts
  </files>
  <action>
Create three foundational modules in src/sync/:

**src/sync/sync-types.ts:**
- Export `SyncStatus` type: `'synced' | 'syncing' | 'offline' | 'error'`
- Export `SyncKeyConfig` interface with fields:
  - `endpoint: string` (e.g., '/api/roster')
  - `mode: 'singleton' | 'collection'`
  - `responseKey?: string` (for batting endpoint's non-standard response -- when the GET response nests data under a specific key instead of `data`)
  - `pushDocType?: string` (for batting endpoint's PUT discriminator -- 'battingOrderState' or 'battingHistory')
- Export `SyncApiResponse` interface: `{ data: unknown; _etag: string | null }`
- Export `BattingApiResponse` interface: `{ battingOrderState: unknown; battingHistory: unknown[] }` (for the non-standard /api/batting GET response)

**src/sync/sync-engine.ts:**
- Module-scope `Map<string, ReturnType<typeof setTimeout>>` for debounce timers
- Module-scope `Set<string>` for pending push keys (to retry on reconnect)

- Export `debouncedPush(key: string, config: SyncKeyConfig, onStatus: (status: SyncStatus) => void): void`
  - Clears existing timer for this key
  - Sets new timer at 2000ms delay
  - When timer fires: calls `pushToCloud(key, config, onStatus)`

- Export `async pushToCloud(key: string, config: SyncKeyConfig, onStatus: (status: SyncStatus) => void): Promise<void>`
  - Read current value from `localStorage.getItem(key)` directly (not from closure -- avoids stale data pitfall)
  - If value is null, return (nothing to push)
  - Set onStatus('syncing')
  - For singleton mode: `PUT {endpoint}` with body `{ data: parsed }`. If config.pushDocType exists (batting), body is `{ docType: config.pushDocType, data: parsed }`.
  - For collection mode: Read the value (which is an array), read `localStorage.getItem(key + ':lastSyncedCount')` to get the last synced count (default 0). Slice the array from lastSyncedCount to end. For each new entry, `PUT {endpoint}` with body `{ data: entry }`. If config.pushDocType exists (batting), add `docType: config.pushDocType` to body. After all entries pushed, write the new count to `localStorage.setItem(key + ':lastSyncedCount', String(array.length))`.
  - On success: remove key from pendingPush set, call onStatus('synced')
  - On network error (fetch throws): add key to pendingPush set, call onStatus('offline')
  - On server error (response not ok, status >= 500): call onStatus('error')
  - On 401: call onStatus('error') (auth expired, don't retry)

- Export `async pullFromCloud(key: string, config: SyncKeyConfig, onStatus: (status: SyncStatus) => void): Promise<void>`
  - Set onStatus('syncing')
  - `GET {endpoint}`
  - On success:
    - For singleton mode: If config.responseKey exists, extract `response[config.responseKey]`, otherwise extract `response.data`. If the extracted data is not null/undefined and is not an empty-object/default, write to `localStorage.setItem(key, JSON.stringify(data))` and dispatch a `local-storage-sync` CustomEvent with `{ key, value: data }` so React state updates (matching useLocalStorage's existing cross-component sync pattern).
    - For collection mode: Extract `response.data` (or `response[config.responseKey]` if set). If it's an array with length > 0, write to localStorage and dispatch sync event. Also set `localStorage.setItem(key + ':lastSyncedCount', String(array.length))` so subsequent pushes only send new entries.
  - On network error: call onStatus('offline') (not a failure -- user works offline)
  - On server error: call onStatus('error')
  - On success or network error: call onStatus('synced') only on success

- Export `retryPendingPushes(onStatus: (key: string, status: SyncStatus) => void, configs: Map<string, SyncKeyConfig>): void`
  - Iterate pendingPush set
  - For each key, if configs has the key's config, call pushToCloud

- Export `cancelAllTimers(): void` -- clears all debounce timers (for cleanup)

IMPORTANT: All fetch calls must NOT include credentials/headers -- SWA EasyAuth uses cookie-based auth automatically on same-origin requests. Use plain `fetch(url, { method, headers: { 'Content-Type': 'application/json' }, body })`.

**src/sync/useOnlineStatus.ts:**
- Export `useOnlineStatus(): boolean`
- useState initialized to `navigator.onLine`
- useEffect adds `online` and `offline` event listeners on `window`
- Returns current online status
- Cleanup removes event listeners
  </action>
  <verify>
Run `npx tsc --noEmit` from project root. All three files should compile without errors. Verify the files exist with correct exports.
  </verify>
  <done>
sync-types.ts exports SyncStatus, SyncKeyConfig, SyncApiResponse, BattingApiResponse. sync-engine.ts exports debouncedPush, pushToCloud, pullFromCloud, retryPendingPushes, cancelAllTimers. useOnlineStatus.ts exports useOnlineStatus hook. All compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SyncContext provider and useCloudStorage hook</name>
  <files>
    src/sync/SyncContext.tsx
    src/sync/useCloudStorage.ts
  </files>
  <action>
Create the React context and the main consumer-facing hook:

**src/sync/SyncContext.tsx:**
- Import SyncStatus from sync-types, useOnlineStatus from useOnlineStatus, retryPendingPushes and cancelAllTimers from sync-engine
- Create SyncContext with `createContext`
- `SyncContextValue` interface: `{ status: SyncStatus; reportStatus: (key: string, status: SyncStatus) => void; registerConfig: (key: string, config: SyncKeyConfig) => void }`
- Default value: `{ status: 'synced', reportStatus: () => {}, registerConfig: () => {} }`
- Export `SyncProvider({ children })`:
  - useState for `keyStatuses: Record<string, SyncStatus>` (initially empty)
  - useRef for `configs: Map<string, SyncKeyConfig>` (stores registered sync configs for retry)
  - `reportStatus` callback: updates keyStatuses for the given key
  - `registerConfig` callback: adds config to configs ref
  - Derive aggregated status from keyStatuses using priority: error > syncing > offline > synced. If any key is 'error', aggregate is 'error'. Else if any 'syncing', aggregate is 'syncing'. Else if any 'offline', aggregate is 'offline'. Else 'synced'. If keyStatuses is empty, default to 'synced'.
  - useOnlineStatus to get `isOnline`
  - useEffect watching `isOnline`: when isOnline transitions from false to true (use a ref to track previous value), call retryPendingPushes with a callback that routes status updates to reportStatus, passing configs ref
  - useEffect cleanup: call cancelAllTimers on unmount
  - Provide `{ status, reportStatus, registerConfig }` to children

- Export `useSyncContext()`: returns `useContext(SyncContext)`

**src/sync/useCloudStorage.ts:**
- Import useLocalStorage from '../hooks/useLocalStorage'
- Import useAuth from '../auth/useAuth'
- Import useSyncContext from './SyncContext'
- Import SyncKeyConfig from './sync-types'
- Import debouncedPush, pullFromCloud from './sync-engine'
- Import useCallback, useEffect, useRef from 'react'

- Export `function useCloudStorage<T>(key: string, initialValue: T, apiConfig: SyncKeyConfig): [T, (value: T | ((prev: T) => T)) => void]`

  Implementation:
  1. Call `useLocalStorage<T>(key, initialValue)` to get `[value, setLocalValue]`
  2. Call `useAuth()` to get `{ user }`
  3. Call `useSyncContext()` to get `{ reportStatus, registerConfig }`
  4. Use a `useRef` for `apiConfig` to avoid stale closure issues and dependency array churn (apiConfig is an object literal in callers, would be new reference every render)
  5. Register config on mount: `useEffect(() => { registerConfig(key, apiConfigRef.current); }, [key, registerConfig])`

  6. **If `!user`:** return `[value, setLocalValue]` directly -- pure localStorage passthrough, no cloud operations.

  IMPORTANT: The hooks below must be called unconditionally (React rules of hooks). The `!user` early return must come AFTER all hook calls. Structure the hook so all useCallback/useEffect calls happen before the auth check. Use the `user` value inside the callbacks/effects to gate cloud operations rather than conditionally calling hooks.

  7. Create wrapped setter via useCallback:
     ```
     const setValue = useCallback((newValue: T | ((prev: T) => T)) => {
       setLocalValue(newValue);
       if (user) {
         debouncedPush(key, apiConfigRef.current, (status) => reportStatus(key, status));
       }
     }, [key, setLocalValue, user, reportStatus]);
     ```

  8. Pull on mount (authenticated only):
     ```
     useEffect(() => {
       if (!user) return;
       pullFromCloud(key, apiConfigRef.current, (status) => reportStatus(key, status));
     }, [key, user, reportStatus]);
     ```
     The pull reads from the API and writes to localStorage + dispatches the local-storage-sync event, which useLocalStorage already listens to. This means the React state updates automatically without useCloudStorage needing to manage it.

  9. Return `[value, setValue]`

  CRITICAL DESIGN NOTES:
  - The setter must NOT await anything. setLocalValue is synchronous (writes to React state which writes to localStorage via useEffect). debouncedPush schedules async work but returns immediately.
  - pullFromCloud dispatches the `local-storage-sync` CustomEvent that useLocalStorage already listens for (see useLocalStorage.ts lines 31-40). This means pulled data flows into React state automatically.
  - apiConfig ref avoids infinite re-render loops from object literal props.
  - The hook signature `[T, setter]` must be identical to useLocalStorage's return type.
  </action>
  <verify>
Run `npx tsc --noEmit` from project root. Both files should compile without errors. Verify useCloudStorage's return type matches useLocalStorage's: `[T, (value: T | ((prev: T) => T)) => void]`.
  </verify>
  <done>
SyncContext.tsx exports SyncProvider and useSyncContext. useCloudStorage.ts exports useCloudStorage with identical signature to useLocalStorage. SyncProvider aggregates per-key statuses, retries on reconnect, and cleans up timers on unmount. useCloudStorage delegates to useLocalStorage, gates cloud ops on auth, and schedules debounced pushes on writes.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with all 5 new files
- All exports match the documented API surface
- useCloudStorage returns same type signature as useLocalStorage
- No new npm dependencies added
</verification>

<success_criteria>
All sync infrastructure files exist in src/sync/ and compile cleanly. useCloudStorage can be called with the same pattern as useLocalStorage plus an apiConfig parameter. SyncProvider aggregates status and triggers retry on reconnect.
</success_criteria>

<output>
After completion, create `.planning/phases/07-sync-engine/07-01-SUMMARY.md`
</output>
