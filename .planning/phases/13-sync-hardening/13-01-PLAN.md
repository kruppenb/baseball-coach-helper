---
phase: 13-sync-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/src/functions/roster.ts
  - api/src/functions/game-config.ts
  - api/src/functions/lineup-state.ts
  - api/src/functions/batting.ts
autonomous: true

must_haves:
  truths:
    - "PUT roster with valid If-Match succeeds and returns updated _etag"
    - "PUT roster with stale If-Match returns 412 with current cloud data, cloudEtag, and cloudUpdatedAt"
    - "PUT roster without If-Match (first-ever save) succeeds unconditionally"
    - "Same If-Match / 412 behavior applies to game-config, lineup-state, and battingOrderState PUT endpoints"
    - "Collection-mode PUT endpoints (gameHistory, battingHistory) remain unchanged — no ETag enforcement"
  artifacts:
    - path: "api/src/functions/roster.ts"
      provides: "putRoster with accessCondition and 412 conflict response"
      contains: "accessCondition"
    - path: "api/src/functions/game-config.ts"
      provides: "putGameConfig with accessCondition and 412 conflict response"
      contains: "accessCondition"
    - path: "api/src/functions/lineup-state.ts"
      provides: "putLineupState with accessCondition and 412 conflict response"
      contains: "accessCondition"
    - path: "api/src/functions/batting.ts"
      provides: "putBatting with accessCondition for battingOrderState only, 412 conflict response"
      contains: "accessCondition"
  key_links:
    - from: "api/src/functions/roster.ts"
      to: "@azure/cosmos container.items.upsert"
      via: "accessCondition option with IfMatch type"
      pattern: "accessCondition.*IfMatch"
    - from: "api/src/functions/roster.ts"
      to: "HTTP 412 response"
      via: "catch block checking statusCode === 412"
      pattern: "statusCode === 412"
---

<objective>
Add optimistic concurrency enforcement to all 4 singleton API PUT endpoints (roster, game-config, lineup-state, battingOrderState) using Cosmos DB ETag-based accessCondition.

Purpose: The API currently accepts writes blindly — last write wins silently. This plan makes the API enforce ETag matching so the frontend can detect when data was modified by another device since last pull. Collection-mode endpoints (gameHistory, battingHistory) are append-only and skip ETag enforcement per research recommendation.

Output: All 4 singleton PUT endpoints accept an optional `If-Match` header, pass it as `accessCondition: { type: 'IfMatch', condition: etag }` to Cosmos `upsert`, and return HTTP 412 with `{ error, cloudData, cloudEtag, cloudUpdatedAt }` when the ETag doesn't match.
</objective>

<execution_context>
@C:/Users/nicho/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicho/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-sync-hardening/13-RESEARCH.md
@api/src/functions/roster.ts
@api/src/functions/game-config.ts
@api/src/functions/lineup-state.ts
@api/src/functions/batting.ts
@api/src/lib/logging.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add If-Match / 412 concurrency to roster, game-config, and lineup-state PUT endpoints</name>
  <files>
    api/src/functions/roster.ts
    api/src/functions/game-config.ts
    api/src/functions/lineup-state.ts
  </files>
  <action>
Apply the same pattern to all 3 singleton PUT functions (putRoster, putGameConfig, putLineupState):

1. Read `If-Match` header from the request:
   ```typescript
   const ifMatch = request.headers.get('if-match');
   ```

2. Build Cosmos upsert options conditionally (only include accessCondition when ifMatch exists — omit entirely for first-ever saves with no stored ETag):
   ```typescript
   const options = ifMatch
     ? { accessCondition: { type: 'IfMatch' as const, condition: ifMatch } }
     : {};
   ```

3. Pass options to the existing `container.items.upsert(doc)` call:
   ```typescript
   const { resource } = await container.items.upsert(doc, options);
   ```

4. Add a 412 catch branch BEFORE the existing generic error handler. When `statusCode === 412`, read the current cloud document and return it in the conflict response:
   ```typescript
   } catch (error) {
     const cosmosErr = error as { statusCode?: number };
     if (cosmosErr.statusCode === 412) {
       const docId = `${DOC_TYPE}-${principal.userId}`;
       try {
         const { resource: current } = await container
           .item(docId, principal.userId)
           .read();
         return {
           status: 412,
           jsonBody: {
             error: 'Conflict: data was modified by another device',
             cloudData: current?.data ?? null,
             cloudEtag: current?._etag ?? null,
             cloudUpdatedAt: current?.updatedAt ?? null,
           },
         };
       } catch (readError) {
         logError(context, 'Failed to read current doc during conflict', readError);
         return { status: 412, jsonBody: { error: 'Conflict detected' } };
       }
     }
     logError(context, 'Failed to upsert ...', error);
     return { status: 500, jsonBody: { error: 'Internal server error' } };
   }
   ```

Important: Keep the existing 401/400 handling untouched. Only modify the upsert call and the catch block in each PUT function.
  </action>
  <verify>
Run `cd api && npx tsc --noEmit` — should compile with no errors. Visually confirm each PUT function has the `if-match` header read, `accessCondition` option, and 412 catch branch.
  </verify>
  <done>
putRoster, putGameConfig, and putLineupState all: (1) read If-Match header, (2) pass accessCondition to upsert when header present, (3) return 412 with cloudData/cloudEtag/cloudUpdatedAt on ETag mismatch, (4) still work without If-Match header for unconditional upsert.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add If-Match / 412 concurrency to batting PUT endpoint (battingOrderState only)</name>
  <files>
    api/src/functions/batting.ts
  </files>
  <action>
The batting endpoint handles two document types via `body.docType`: `battingOrderState` (singleton) and `battingHistory` (collection/append-only).

Only add ETag enforcement to the `battingOrderState` branch. Leave the `battingHistory` branch unchanged.

1. Read `If-Match` header at the top of `putBatting`:
   ```typescript
   const ifMatch = request.headers.get('if-match');
   ```

2. In the `if (body.docType === 'battingOrderState')` branch, build options and pass to upsert:
   ```typescript
   const options = ifMatch
     ? { accessCondition: { type: 'IfMatch' as const, condition: ifMatch } }
     : {};
   const { resource } = await container.items.upsert(doc, options);
   ```

3. Add 412 handling in the outer catch block. Since both branches share the catch, check `statusCode === 412` and handle it:
   ```typescript
   } catch (error) {
     const cosmosErr = error as { statusCode?: number };
     if (cosmosErr.statusCode === 412) {
       // Only battingOrderState uses accessCondition, so conflict is for that doc
       const docId = `battingOrderState-${principal.userId}`;
       try {
         const { resource: current } = await container
           .item(docId, principal.userId)
           .read();
         return {
           status: 412,
           jsonBody: {
             error: 'Conflict: data was modified by another device',
             cloudData: current?.data ?? null,
             cloudEtag: current?._etag ?? null,
             cloudUpdatedAt: current?.updatedAt ?? null,
           },
         };
       } catch (readError) {
         logError(context, 'Failed to read current doc during conflict', readError);
         return { status: 412, jsonBody: { error: 'Conflict detected' } };
       }
     }
     logError(context, 'Failed to upsert batting data', error);
     return { status: 500, jsonBody: { error: 'Internal server error' } };
   }
   ```

Important: Do NOT add accessCondition to the battingHistory upsert (the else branch). battingHistory entries are append-only with unique IDs per research guidance.

Also verify: the `principal` variable is in scope inside the catch block (it is — declared at function top).
  </action>
  <verify>
Run `cd api && npx tsc --noEmit` — should compile with no errors. Confirm batting.ts has accessCondition only in the battingOrderState branch, not the battingHistory branch.
  </verify>
  <done>
putBatting enforces ETag concurrency on battingOrderState upserts only. battingHistory upserts remain unconditional. 412 response includes cloudData/cloudEtag/cloudUpdatedAt for battingOrderState conflicts.
  </done>
</task>

</tasks>

<verification>
1. `cd api && npx tsc --noEmit` passes with zero errors
2. All 4 singleton PUT functions (roster, game-config, lineup-state, batting/battingOrderState) contain:
   - `request.headers.get('if-match')` call
   - `accessCondition: { type: 'IfMatch'` in options
   - `statusCode === 412` check in catch block
   - 412 response body with `cloudData`, `cloudEtag`, `cloudUpdatedAt`
3. Collection PUT functions (gameHistory, battingHistory) have NO accessCondition
4. PUT without If-Match header still works (unconditional upsert path)
</verification>

<success_criteria>
API enforces optimistic concurrency on all 4 singleton PUT endpoints. Stale If-Match returns 412 with cloud data for conflict resolution. Missing If-Match allows unconditional upsert for backward compatibility.
</success_criteria>

<output>
After completion, create `.planning/phases/13-sync-hardening/13-01-SUMMARY.md`
</output>
