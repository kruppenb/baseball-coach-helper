---
phase: 13-sync-hardening
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/sync/sync-types.ts
  - src/sync/sync-engine.ts
  - src/sync/SyncContext.tsx
  - src/sync/useCloudStorage.ts
  - src/sync/ConflictDialog.tsx
  - src/sync/ConflictDialog.module.css
autonomous: true

must_haves:
  truths:
    - "App stores ETag from every successful pull and push response"
    - "Push requests include If-Match header with stored ETag when one exists"
    - "When API returns 412, app shows a conflict dialog with 'Keep This Device' and 'Keep Cloud' buttons and cloud timestamp"
    - "Choosing 'Keep This Device' re-pushes local data with the fresh cloud ETag from the 412 response"
    - "Choosing 'Keep Cloud' writes cloud data to localStorage and updates the stored ETag"
    - "Active in-progress edits (dirty keys) are not overwritten by background cloud pulls"
  artifacts:
    - path: "src/sync/sync-types.ts"
      provides: "ConflictInfo type definition"
      contains: "ConflictInfo"
    - path: "src/sync/sync-engine.ts"
      provides: "ETag store, dirty flag, If-Match header, 412 handling"
      contains: "etagStore"
    - path: "src/sync/ConflictDialog.tsx"
      provides: "Modal dialog for conflict resolution"
      contains: "ConflictDialog"
    - path: "src/sync/ConflictDialog.module.css"
      provides: "Styles for conflict dialog"
      contains: "dialog"
    - path: "src/sync/SyncContext.tsx"
      provides: "Conflict state management and dialog rendering"
      contains: "ConflictDialog"
    - path: "src/sync/useCloudStorage.ts"
      provides: "Dirty flag integration via markDirty on edits"
      contains: "markDirty"
  key_links:
    - from: "src/sync/sync-engine.ts"
      to: "API PUT endpoints"
      via: "If-Match header in fetch"
      pattern: "If-Match.*etagStore"
    - from: "src/sync/sync-engine.ts"
      to: "src/sync/SyncContext.tsx"
      via: "onConflict callback from pushToCloud"
      pattern: "onConflict"
    - from: "src/sync/SyncContext.tsx"
      to: "src/sync/ConflictDialog.tsx"
      via: "conflict state passed as prop"
      pattern: "conflict.*ConflictDialog"
    - from: "src/sync/useCloudStorage.ts"
      to: "src/sync/sync-engine.ts"
      via: "markDirty call in setValue"
      pattern: "markDirty"
---

<objective>
Wire ETag tracking, dirty flag protection, 412 conflict handling, and a conflict resolution dialog into the frontend sync engine so the coach sees a choice dialog when their push conflicts with cloud data.

Purpose: The API now returns 412 on ETag mismatch (Plan 01), but the frontend ignores ETags and doesn't send If-Match headers. This plan completes the loop: store ETags from GET/PUT responses, send them back on pushes, detect 412 conflicts, show a two-column dialog ("This Device" vs "Cloud" with timestamps), and resolve the conflict per the coach's choice. It also adds a dirty flag to prevent background pulls from overwriting active edits.

Output: Complete frontend conflict resolution flow — from ETag tracking through conflict dialog to resolution.
</objective>

<execution_context>
@C:/Users/nicho/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicho/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-sync-hardening/13-RESEARCH.md
@.planning/phases/13-sync-hardening/13-01-SUMMARY.md
@src/sync/sync-types.ts
@src/sync/sync-engine.ts
@src/sync/SyncContext.tsx
@src/sync/useCloudStorage.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ETag store, dirty flags, If-Match header, and 412 handling to sync engine</name>
  <files>
    src/sync/sync-types.ts
    src/sync/sync-engine.ts
    src/sync/useCloudStorage.ts
  </files>
  <action>
**sync-types.ts** — Add the ConflictInfo type after the existing types:
```typescript
export interface ConflictInfo {
  key: string;
  localData: unknown;
  cloudData: unknown;
  cloudEtag: string | null;
  cloudUpdatedAt: string | null;
}
```

**sync-engine.ts** — Add three module-level data structures and modify push/pull functions:

1. Add module-level stores after the existing `pulledKeys` Set:
```typescript
/** ETags from the last successful GET or PUT per sync key */
const etagStore = new Map<string, string>();

/** Keys with unsaved local edits — prevents pullFromCloud from overwriting active work */
const dirtyKeys = new Set<string>();
```

2. Export helper functions for the stores:
```typescript
export function getStoredEtag(key: string): string | undefined {
  return etagStore.get(key);
}

export function setStoredEtag(key: string, etag: string): void {
  etagStore.set(key, etag);
}

export function markDirty(key: string): void {
  dirtyKeys.add(key);
}

export function clearDirty(key: string): void {
  dirtyKeys.delete(key);
}

export function isDirty(key: string): boolean {
  return dirtyKeys.has(key);
}
```

3. Modify `pushToCloud` signature to accept an optional `onConflict` callback:
```typescript
export async function pushToCloud(
  key: string,
  config: SyncKeyConfig,
  onStatus: (status: SyncStatus) => void,
  onConflict?: (info: ConflictInfo) => void,
): Promise<void> {
```
Import `ConflictInfo` from sync-types.

4. Inside `pushToCloud`, in the singleton branch, add If-Match header when an ETag is stored:
```typescript
const headers: Record<string, string> = { 'Content-Type': 'application/json' };
const storedEtag = etagStore.get(key);
if (storedEtag) {
  headers['If-Match'] = storedEtag;
}
```
Use this `headers` object in the `fetch()` call instead of the inline `{ 'Content-Type': 'application/json' }`.

5. After the `fetch()` call in the singleton branch, handle 412 BEFORE the existing `!response.ok` check:
```typescript
if (response.status === 412 && onConflict) {
  const conflict = await response.json();
  onConflict({
    key,
    localData: parsed,
    cloudData: conflict.cloudData ?? null,
    cloudEtag: conflict.cloudEtag ?? null,
    cloudUpdatedAt: conflict.cloudUpdatedAt ?? null,
  });
  onStatus('error');
  return;
}
```

6. On successful push (where `onStatus('synced')` is called after the singleton branch), update the stored ETag from the response:
```typescript
if (response.ok) {
  const result = await response.json();
  if (result._etag) {
    etagStore.set(key, result._etag);
  }
  dirtyKeys.delete(key);
}
```
Note: The existing code doesn't parse the response on success — add this parsing. Also clear the dirty flag on success.

7. Modify `pullFromCloud` to skip if the key is dirty (add after the existing `pulledKeys.has(key)` guard):
```typescript
if (dirtyKeys.has(key)) {
  onStatus('synced');
  return;
}
```

8. In `pullFromCloud`, after successfully parsing the response JSON, store the ETag:
```typescript
const json = (await response.json()) as Record<string, unknown>;
if (typeof json._etag === 'string') {
  etagStore.set(key, json._etag);
}
```
For the batting endpoint (collection mode responseKey), the ETag is not applicable — only store for singleton mode.

9. Update `debouncedPush` signature to pass through `onConflict`:
```typescript
export function debouncedPush(
  key: string,
  config: SyncKeyConfig,
  onStatus: (status: SyncStatus) => void,
  onConflict?: (info: ConflictInfo) => void,
): void {
```
Pass `onConflict` through to `pushToCloud` in the setTimeout callback. Also add `dirtyKeys.add(key)` at the top of `debouncedPush` (mark dirty immediately when edit starts).

10. Update `retryPendingPushes` — it calls `pushToCloud` without `onConflict`. That's fine — conflict retries from offline→online will just fail silently on 412 since there's no dialog to show. The next manual edit will trigger proper conflict handling.

**useCloudStorage.ts** — Wire dirty flag and conflict callback:

1. Import `markDirty` from sync-engine.
2. In the `setValue` callback, call `markDirty(key)` before `debouncedPush`:
```typescript
const setValue = useCallback(
  (newValue: T | ((prev: T) => T)) => {
    setLocalValue(newValue);
    if (user) {
      markDirty(key);
      debouncedPush(key, apiConfigRef.current, (status) =>
        reportStatus(key, status)
      );
    }
  },
  [key, setLocalValue, user, reportStatus]
);
```
Note: `onConflict` will be wired through SyncContext (Task 2), not directly from useCloudStorage. For now, just add markDirty. The debouncedPush onConflict parameter will be wired in Task 2 when SyncContext provides the conflict handler.
  </action>
  <verify>
Run `npm run build` from the repo root — should compile with no TypeScript errors. Verify `etagStore`, `dirtyKeys`, `markDirty`, `ConflictInfo` exist in the built output. Check that `pushToCloud` accepts the `onConflict` parameter and handles 412.
  </verify>
  <done>
Sync engine tracks ETags per key, sends If-Match on pushes, handles 412 responses by invoking onConflict callback, marks keys as dirty on edits, and skips pulls for dirty keys. ConflictInfo type is defined in sync-types.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ConflictDialog component and wire conflict state through SyncContext</name>
  <files>
    src/sync/ConflictDialog.tsx
    src/sync/ConflictDialog.module.css
    src/sync/SyncContext.tsx
    src/sync/useCloudStorage.ts
  </files>
  <action>
**ConflictDialog.tsx** — Create a new component using native HTML `<dialog>`:

```typescript
import { useRef, useEffect } from 'react';
import type { ConflictInfo } from './sync-types';
import styles from './ConflictDialog.module.css';

interface ConflictDialogProps {
  conflict: ConflictInfo | null;
  onResolve: (choice: 'local' | 'cloud') => void;
}

export function ConflictDialog({ conflict, onResolve }: ConflictDialogProps) {
  const dialogRef = useRef<HTMLDialogElement>(null);

  useEffect(() => {
    if (conflict) {
      dialogRef.current?.showModal();
    } else {
      dialogRef.current?.close();
    }
  }, [conflict]);

  if (!conflict) return null;

  const cloudTime = conflict.cloudUpdatedAt
    ? new Date(conflict.cloudUpdatedAt).toLocaleString()
    : 'Unknown';

  return (
    <dialog ref={dialogRef} className={styles.dialog}>
      <h2 className={styles.title}>Sync Conflict</h2>
      <p className={styles.description}>
        Your data was changed on another device since your last sync. Choose which version to keep.
      </p>

      <div className={styles.columns}>
        <div className={styles.column}>
          <h3>This Device</h3>
          <p className={styles.timestamp}>Your current changes</p>
          <button
            className={styles.choiceButton}
            onClick={() => onResolve('local')}
          >
            Keep This Device
          </button>
        </div>

        <div className={styles.divider} />

        <div className={styles.column}>
          <h3>Cloud</h3>
          <p className={styles.timestamp}>Last saved: {cloudTime}</p>
          <button
            className={styles.choiceButton}
            onClick={() => onResolve('cloud')}
          >
            Keep Cloud
          </button>
        </div>
      </div>
    </dialog>
  );
}
```

Key details:
- Use `.showModal()` (not `.show()`) for focus trapping and backdrop
- Prevent default Escape-to-close by NOT adding a cancel event handler — let the coach deliberately choose. Actually, add a `cancel` event handler that calls `preventDefault()` so Escape doesn't dismiss without choosing:
  ```typescript
  useEffect(() => {
    const dialog = dialogRef.current;
    if (!dialog) return;
    const handleCancel = (e: Event) => e.preventDefault();
    dialog.addEventListener('cancel', handleCancel);
    return () => dialog.removeEventListener('cancel', handleCancel);
  }, []);
  ```

**ConflictDialog.module.css** — Style the dialog:

- `dialog` selector: max-width 480px, border-radius 8px, border none, box-shadow for elevation, padding 1.5rem. Use `::backdrop` pseudo-element for semi-transparent overlay.
- `.columns`: display flex, gap 1rem, margin-top 1rem.
- `.column`: flex 1, text-align center.
- `.divider`: width 1px, background-color var(--color-border, #ddd).
- `.choiceButton`: full-width buttons, padding 0.75rem, border-radius 4px, cursor pointer. "Keep This Device" gets primary style (var(--color-primary, #2563eb) background, white text). "Keep Cloud" gets secondary style (outlined, border 1px solid).
- `.title`: margin 0 0 0.5rem.
- `.description`: color var(--color-text-secondary, #666), margin 0 0 1rem.
- `.timestamp`: font-size 0.875rem, color var(--color-text-secondary, #666), min-height 1.25rem.

Use existing CSS custom properties from the project's tokens.css where available.

**SyncContext.tsx** — Add conflict state and wire the dialog:

1. Import `ConflictInfo` from sync-types, `ConflictDialog` from ConflictDialog, `setStoredEtag` and `clearDirty` from sync-engine.

2. Add conflict state to the provider:
```typescript
const [activeConflict, setActiveConflict] = useState<ConflictInfo | null>(null);
```

3. Add a `handleConflict` callback:
```typescript
const handleConflict = useCallback((info: ConflictInfo) => {
  setActiveConflict(info);
}, []);
```

4. Add a `resolveConflict` callback that handles both choices:
```typescript
const resolveConflict = useCallback((choice: 'local' | 'cloud') => {
  if (!activeConflict) return;
  const { key, cloudData, cloudEtag } = activeConflict;

  if (choice === 'cloud') {
    // Write cloud data to localStorage and update ETag
    localStorage.setItem(key, JSON.stringify(cloudData));
    window.dispatchEvent(
      new CustomEvent('local-storage-sync', {
        detail: { key, value: cloudData },
      })
    );
    if (cloudEtag) {
      setStoredEtag(key, cloudEtag);
    }
    clearDirty(key);
    reportStatus(key, 'synced');
  } else {
    // "Keep this device": re-push with the fresh cloud ETag so next upsert succeeds
    if (cloudEtag) {
      setStoredEtag(key, cloudEtag);
    }
    // Trigger an immediate push (not debounced) for this key
    const config = configsRef.current.get(key);
    if (config) {
      import('./sync-engine').then(({ pushToCloud }) => {
        pushToCloud(key, config, (status) => reportStatus(key, status), handleConflict);
      });
    }
  }
  setActiveConflict(null);
}, [activeConflict, reportStatus, handleConflict]);
```

Actually, to avoid dynamic import, import `pushToCloud` at the top (it's already imported indirectly via `retryPendingPushes`). Add `pushToCloud` to the existing import from sync-engine:
```typescript
import {
  retryPendingPushes,
  cancelAllTimers,
  migrateLocalData,
  pushToCloud,
  setStoredEtag,
  clearDirty,
} from './sync-engine';
```

5. Expose `handleConflict` via the context value so `useCloudStorage` can pass it to `debouncedPush`. Add to the SyncContextValue interface:
```typescript
interface SyncContextValue {
  status: SyncStatus;
  reportStatus: (key: string, status: SyncStatus) => void;
  registerConfig: (key: string, config: SyncKeyConfig) => void;
  onConflict: (info: ConflictInfo) => void;
}
```
Update the default context value to include `onConflict: () => {}`.

6. Render `ConflictDialog` at the bottom of the provider's return JSX:
```typescript
return (
  <SyncContext.Provider value={{ status, reportStatus, registerConfig, onConflict: handleConflict }}>
    {children}
    <ConflictDialog conflict={activeConflict} onResolve={resolveConflict} />
  </SyncContext.Provider>
);
```

**useCloudStorage.ts** — Wire the conflict callback through to debouncedPush:

1. Destructure `onConflict` from `useSyncContext()`:
```typescript
const { reportStatus, registerConfig, onConflict } = useSyncContext();
```

2. Pass `onConflict` as the 4th argument to `debouncedPush` in the setValue callback:
```typescript
debouncedPush(key, apiConfigRef.current, (status) =>
  reportStatus(key, status),
  onConflict
);
```
  </action>
  <verify>
Run `npm run build` from the repo root — should compile with no errors. Verify ConflictDialog.tsx exists with native `<dialog>` and two choice buttons. Verify SyncContext renders ConflictDialog and exposes onConflict. Verify useCloudStorage passes onConflict to debouncedPush.
  </verify>
  <done>
Complete conflict resolution flow works: (1) push sends If-Match, (2) 412 triggers conflict state in SyncContext, (3) ConflictDialog shows with "Keep This Device" / "Keep Cloud" options and cloud timestamp, (4) "Keep Cloud" writes cloud data to localStorage and syncs React state, (5) "Keep This Device" updates ETag and re-pushes local data, (6) dirty flag prevents background pulls from overwriting active edits.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` (root) and `cd api && npx tsc --noEmit` both pass with zero errors
2. sync-engine.ts exports: etagStore helpers, markDirty/clearDirty/isDirty, updated pushToCloud with If-Match and 412 handling
3. sync-types.ts exports ConflictInfo interface
4. ConflictDialog.tsx renders a native `<dialog>` with two resolution buttons and cloud timestamp
5. SyncContext.tsx manages activeConflict state, renders ConflictDialog, exposes onConflict via context
6. useCloudStorage.ts calls markDirty on edits and passes onConflict to debouncedPush
7. pullFromCloud skips when dirtyKeys contains the key
8. Successful push/pull responses update etagStore with returned _etag
</verification>

<success_criteria>
Frontend sync engine stores ETags, sends If-Match on pushes, shows a conflict dialog on 412 with "This Device" vs "Cloud" choices, and protects active edits from being overwritten by background pulls. Coach can resolve conflicts by choosing which version to keep.
</success_criteria>

<output>
After completion, create `.planning/phases/13-sync-hardening/13-02-SUMMARY.md`
</output>
