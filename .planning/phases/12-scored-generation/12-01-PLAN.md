---
phase: 12-scored-generation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/logic/lineup-scorer.ts
  - src/logic/lineup-scorer.test.ts
  - src/logic/shuffle.ts
  - src/logic/lineup-generator.ts
  - src/logic/lineup-generator.test.ts
  - src/logic/batting-order.ts
autonomous: true

must_haves:
  truths:
    - "scoreLineup() returns a LineupScore with total (0-100), benchEquity, infieldBalance, and positionVariety sub-scores"
    - "generateBestLineup() generates ~10 lineups, scores each, and returns the highest-scoring valid lineup"
    - "Fisher-Yates shuffle is defined once in shuffle.ts and imported by both lineup-generator.ts and batting-order.ts"
  artifacts:
    - path: "src/logic/lineup-scorer.ts"
      provides: "scoreLineup function with three sub-dimension scoring"
      exports: ["scoreLineup", "LineupScore"]
    - path: "src/logic/lineup-scorer.test.ts"
      provides: "Unit tests for scoring edge cases"
      min_lines: 50
    - path: "src/logic/shuffle.ts"
      provides: "Shared Fisher-Yates shuffle utility"
      exports: ["shuffle"]
  key_links:
    - from: "src/logic/lineup-generator.ts"
      to: "src/logic/lineup-scorer.ts"
      via: "generateBestLineup imports scoreLineup"
      pattern: "import.*scoreLineup.*lineup-scorer"
    - from: "src/logic/lineup-generator.ts"
      to: "src/logic/shuffle.ts"
      via: "import shared shuffle"
      pattern: "import.*shuffle.*shuffle"
    - from: "src/logic/batting-order.ts"
      to: "src/logic/shuffle.ts"
      via: "import shared shuffle"
      pattern: "import.*shuffle.*shuffle"
---

<objective>
Build the lineup scoring algorithm and best-of-N generation orchestrator with shared shuffle utility.

Purpose: This is the scoring engine that makes Phase 12 possible -- it numerically ranks lineups by fairness so the app can auto-select the best one instead of asking the coach to choose.

Output: `scoreLineup()` function, `generateBestLineup()` orchestrator, shared `shuffle()` utility, and comprehensive unit tests.
</objective>

<execution_context>
@C:/Users/nicho/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicho/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-scored-generation/12-RESEARCH.md

@src/logic/lineup-generator.ts
@src/logic/lineup-types.ts
@src/logic/batting-order.ts
@src/types/index.ts
@src/logic/lineup-generator.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared shuffle utility and lineup scoring function with tests</name>
  <files>
    src/logic/shuffle.ts
    src/logic/lineup-scorer.ts
    src/logic/lineup-scorer.test.ts
  </files>
  <action>
**1. Create `src/logic/shuffle.ts`** — Extract the Fisher-Yates shuffle that's duplicated in lineup-generator.ts and batting-order.ts:

```typescript
/** Fisher-Yates shuffle (unbiased) */
export function shuffle<T>(arr: T[]): T[] {
  const result = [...arr];
  for (let i = result.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result;
}
```

**2. Create `src/logic/lineup-scorer.ts`** with these exports:

```typescript
export interface LineupScore {
  total: number;           // 0-100, weighted average
  benchEquity: number;     // 0-100
  infieldBalance: number;  // 0-100
  positionVariety: number; // 0-100
}
```

`scoreLineup(lineup: Lineup, input: GenerateLineupInput): LineupScore`

**Sub-dimension implementations:**

*benchEquity (weight 0.5):*
- For each player, count innings on bench (not assigned to any position).
- If nobody sits (exactly 9 players for 9 positions): return 100.
- If all players sit equally (spread = 0): return 100.
- Otherwise: `100 * (1 - (maxBench - minBench) / innings)`. Clamp to 0. The max possible spread equals `innings` (one player benched every inning), so dividing by `innings` normalizes to 0-1.

*infieldBalance (weight 0.3):*
- For each player, count innings at non-battery infield positions (1B, 2B, 3B, SS). Exclude P/C innings from this count.
- Compute standard deviation of those counts across all present players.
- Max possible stdDev for N players across I innings is approximately `I/2` (worst case: half get all infield, half get none).
- Score: `100 * (1 - stdDev / maxStdDev)`. Clamp to 0. If only 9 players (no bench), use `innings` as the denominator since all play every inning.

*positionVariety (weight 0.2):*
- For each player, count unique non-P/C positions played across all innings. Exclude innings where player is P, C, or benched.
- Average the unique position counts across all players.
- Max possible unique positions = min(innings, 7) (7 non-P/C positions).
- Score: `100 * (averageUnique / maxPossible)`. Clamp to [0, 100].

*total:* `benchEquity * 0.5 + infieldBalance * 0.3 + positionVariety * 0.2`. Round to 1 decimal.

Export weights as named constants: `BENCH_EQUITY_WEIGHT = 0.5`, `INFIELD_BALANCE_WEIGHT = 0.3`, `POSITION_VARIETY_WEIGHT = 0.2`.

Import `Lineup, POSITIONS, INFIELD_POSITIONS, Position` from `../types/index.ts` and `GenerateLineupInput` from `./lineup-types.ts`.

**3. Create `src/logic/lineup-scorer.test.ts`** with Vitest:

Test cases (RED then GREEN):

a. **Perfect lineup (9 players, no bench):** benchEquity = 100, total should be high.

b. **All bench evenly distributed:** 11 players, 6 innings, each player benched exactly 2 innings (hypothetical even spread). benchEquity should be 100 since max-min = 0.

c. **Uneven bench:** One player benched 4 innings while another benched 0. benchEquity should be penalized (< 70).

d. **High infield balance:** All players have similar infield inning counts. infieldBalance should be high.

e. **Low position variety:** Every player plays the same position each inning. positionVariety should be low.

f. **Score is between 0 and 100 inclusive:** Property test with a generated lineup from `generateLineup()`.

Build test fixtures by constructing `Lineup` objects manually with known assignments. Use `GenerateLineupInput` with minimal player arrays (9-11 players).

Run: `npx vitest run src/logic/lineup-scorer.test.ts`
  </action>
  <verify>
`npx vitest run src/logic/lineup-scorer.test.ts` — all tests pass.
`npx tsc --noEmit` — no type errors.
  </verify>
  <done>
scoreLineup() returns LineupScore with total/benchEquity/infieldBalance/positionVariety all in 0-100 range. Shared shuffle.ts exists and exports shuffle(). All scorer tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add generateBestLineup to lineup-generator and deduplicate shuffle imports</name>
  <files>
    src/logic/lineup-generator.ts
    src/logic/batting-order.ts
    src/logic/lineup-generator.test.ts
  </files>
  <action>
**1. Update `src/logic/lineup-generator.ts`:**

- Replace the local `shuffle()` function definition (lines 8-16) with an import from the shared module:
  ```typescript
  import { shuffle } from './shuffle.ts';
  ```
- Remove the local Fisher-Yates implementation entirely.

- Add a new exported function `generateBestLineup()`:

```typescript
import { scoreLineup } from './lineup-scorer.ts';
import type { LineupScore } from './lineup-scorer.ts';

export interface GenerateBestLineupResult extends GenerateLineupResult {
  score: LineupScore;
}

export function generateBestLineup(
  input: GenerateLineupInput,
  count: number = 10,
): GenerateBestLineupResult {
  const preErrors = preValidate(input);
  if (preErrors.length > 0) {
    return {
      lineup: {} as Lineup,
      valid: false,
      errors: preErrors.map(msg => ({
        rule: 'GRID_COMPLETE' as const,
        message: msg,
      })),
      attemptCount: 0,
      score: { total: 0, benchEquity: 0, infieldBalance: 0, positionVariety: 0 },
    };
  }

  const scored: GenerateBestLineupResult[] = [];

  for (let i = 0; i < count; i++) {
    const result = generateLineup(input);
    if (result.valid) {
      const score = scoreLineup(result.lineup, input);
      scored.push({ ...result, score });
    }
  }

  if (scored.length === 0) {
    return {
      lineup: {} as Lineup,
      valid: false,
      errors: [{
        rule: 'GRID_COMPLETE',
        message: 'Could not generate a valid lineup with these settings. Try adjusting pitcher/catcher assignments or position blocks.',
      }],
      attemptCount: count * 200,
      score: { total: 0, benchEquity: 0, infieldBalance: 0, positionVariety: 0 },
    };
  }

  scored.sort((a, b) => b.score.total - a.score.total);
  return scored[0];
}
```

Keep `generateMultipleLineups()` as-is since it may still be used elsewhere (it was used historically; safe to leave).

**2. Update `src/logic/batting-order.ts`:**

- Replace the local `shuffle()` function definition with an import:
  ```typescript
  import { shuffle } from './shuffle.ts';
  ```
- Remove the local Fisher-Yates implementation and its comment about duplication.

**3. Update `src/logic/lineup-generator.test.ts`:**

Add tests for `generateBestLineup()`:

a. **Returns a valid lineup with score:** Call `generateBestLineup(validInput)`, assert `result.valid === true`, assert `result.score.total` is between 0 and 100.

b. **Returns best of multiple:** This is hard to test deterministically due to randomness, but assert that calling with `count=5` still returns a valid result with a score.

c. **Handles impossible input gracefully:** Pass input with fewer than 9 players, assert `result.valid === false`.

d. **Existing tests still pass:** All existing `generateLineup()` and `generateMultipleLineups()` tests must continue passing after the shuffle import change.

Run: `npx vitest run src/logic/lineup-generator.test.ts src/logic/batting-order.test.ts`
  </action>
  <verify>
`npx vitest run src/logic/` — all logic tests pass (lineup-generator, batting-order, lineup-scorer).
`npx tsc --noEmit` — no type errors.
Verify no local `shuffle` function remains in lineup-generator.ts or batting-order.ts: `grep -n "function shuffle" src/logic/lineup-generator.ts src/logic/batting-order.ts` should return nothing.
  </verify>
  <done>
generateBestLineup() exported from lineup-generator.ts, returns best-scored lineup from N attempts. Both lineup-generator.ts and batting-order.ts import shuffle from shared shuffle.ts. All existing tests continue passing plus new generateBestLineup tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run src/logic/` — all logic tests pass
2. `npx tsc --noEmit` — no TypeScript errors
3. `grep -rn "function shuffle" src/logic/lineup-generator.ts src/logic/batting-order.ts` — no local shuffle definitions remain
4. `grep -n "import.*shuffle.*shuffle" src/logic/lineup-generator.ts src/logic/batting-order.ts` — both import from shared module
5. `grep -n "generateBestLineup" src/logic/lineup-generator.ts` — function is exported
6. `grep -n "scoreLineup" src/logic/lineup-scorer.ts` — function is exported
</verification>

<success_criteria>
- scoreLineup() scores a lineup across three weighted sub-dimensions (bench equity 0.5, infield balance 0.3, position variety 0.2) returning values in 0-100 range
- generateBestLineup() generates N lineups, scores each, returns the highest-scoring valid one
- Fisher-Yates shuffle deduplicated into src/logic/shuffle.ts, imported by both lineup-generator.ts and batting-order.ts
- All existing and new tests pass
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-scored-generation/12-01-SUMMARY.md`
</output>
