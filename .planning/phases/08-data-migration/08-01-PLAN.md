---
phase: 08-data-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/sync/sync-engine.ts
  - src/sync/SyncContext.tsx
autonomous: true

must_haves:
  truths:
    - "On first sign-in, existing localStorage roster, game config, and game history appear in the coach's cloud account without manual action"
    - "Migration does not run for brand-new users who have only default localStorage values"
    - "Migration does not overwrite cloud data that already exists from another device"
    - "Migration runs in the background without blocking the UI (sync indicator shows Syncing then Synced)"
    - "Migration does not re-run after the first successful completion (idempotent via localStorage flag)"
    - "All existing tests continue to pass after the migration code is added"
  artifacts:
    - path: "src/sync/sync-engine.ts"
      provides: "migrateLocalData function and hasNonDefaultData helper"
      contains: "migrateLocalData"
    - path: "src/sync/SyncContext.tsx"
      provides: "Migration trigger effect in SyncProvider"
      contains: "migrateLocalData"
  key_links:
    - from: "src/sync/SyncContext.tsx"
      to: "src/sync/sync-engine.ts"
      via: "import and call migrateLocalData"
      pattern: "migrateLocalData"
    - from: "src/sync/sync-engine.ts migrateLocalData"
      to: "src/sync/sync-engine.ts pushToCloud"
      via: "reuses existing pushToCloud for each key"
      pattern: "pushToCloud\\(key"
    - from: "src/sync/SyncContext.tsx migration effect"
      to: "useAuth user"
      via: "triggers only when user is authenticated"
      pattern: "user.*migrateLocalData|migrateLocalData.*user"
---

<objective>
Add automatic one-time migration of existing localStorage data to the cloud on first sign-in.

Purpose: v1.0 coaches who sign in for the first time need their roster, game config, lineup state, and game history pushed to their new cloud account without any manual action. The sync engine (Phase 7) handles ongoing sync but does not cover the "localStorage has data, cloud is empty" initial migration case.

Output: A `migrateLocalData()` function in sync-engine.ts and a trigger effect in SyncProvider that runs it once after the first authentication, using the existing pushToCloud infrastructure.
</objective>

<execution_context>
@C:/Users/nicho/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicho/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-data-migration/08-RESEARCH.md
@.planning/phases/07-sync-engine/07-01-SUMMARY.md
@.planning/phases/07-sync-engine/07-02-SUMMARY.md

@src/sync/sync-engine.ts
@src/sync/sync-types.ts
@src/sync/SyncContext.tsx
@src/sync/useCloudStorage.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add migrateLocalData function and hasNonDefaultData helper to sync-engine.ts</name>
  <files>src/sync/sync-engine.ts</files>
  <action>
Add two exported functions to `src/sync/sync-engine.ts`:

**1. `hasNonDefaultData(key: string): boolean`**
Checks if a localStorage key contains real user data (not just hook defaults). Logic per key:
- `roster`: `Array.isArray(parsed) && parsed.length > 0`
- `gameConfig`: `parsed?.innings !== undefined && parsed.innings !== 6` (6 is the default)
- `lineupState`: any of `pitcherAssignments`, `catcherAssignments`, `positionBlocks` has >0 keys, OR `generatedLineups.length > 0`
- `battingOrderState`: `parsed?.currentOrder !== null`
- `gameHistory`: `Array.isArray(parsed) && parsed.length > 0`
- `battingHistory`: `Array.isArray(parsed) && parsed.length > 0`
- Default: `false`

Returns false if localStorage.getItem returns null, if JSON.parse fails, or if the key is not recognized.

**2. `migrateLocalData(onStatus: (status: SyncStatus) => void): Promise<boolean>`**
Orchestrates the one-time migration:
- Early return `true` if `localStorage.getItem('migration-complete') === 'true'`
- Define migration configs array (6 entries matching the keys above with their SyncKeyConfig):
  - `{ key: 'roster', config: { endpoint: '/api/roster', mode: 'singleton' } }`
  - `{ key: 'gameConfig', config: { endpoint: '/api/game-config', mode: 'singleton' } }`
  - `{ key: 'lineupState', config: { endpoint: '/api/lineup-state', mode: 'singleton' } }`
  - `{ key: 'battingOrderState', config: { endpoint: '/api/batting', mode: 'singleton', pushDocType: 'battingOrderState' } }`
  - `{ key: 'gameHistory', config: { endpoint: '/api/game-history', mode: 'collection' } }`
  - `{ key: 'battingHistory', config: { endpoint: '/api/batting', mode: 'collection', pushDocType: 'battingHistory' } }`
- Filter to only keys where `hasNonDefaultData(key)` returns true
- If no keys need migration: set `migration-complete` flag and return `true` (brand-new user with defaults)
- Call `onStatus('syncing')`
- Loop through keys needing migration: call `await pushToCloud(key, config, onStatus)` for each
- Use try/catch around the loop. If any push throws (network error), do NOT set the `migration-complete` flag, call `onStatus('error')`, return `false`
- After all succeed: `localStorage.setItem('migration-complete', 'true')`, call `onStatus('synced')`, return `true`

IMPORTANT: Reuse the existing `pushToCloud` function -- do NOT hand-roll fetch calls. pushToCloud already handles singleton vs collection mode, the batting endpoint's pushDocType discriminator, and lastSyncedCount updates for collections.

IMPORTANT: pushToCloud catches network errors internally and calls onStatus('offline') rather than throwing. However, it does NOT throw on HTTP errors either (it calls onStatus('error') and returns). This means the for-loop will continue even if a push fails with a server error. To detect partial failure: check onStatus calls. The simplest approach: create a local `let hadError = false` flag, wrap onStatus so that if it receives 'error' or 'offline', set hadError = true. After the loop, only set migration-complete if !hadError.
  </action>
  <verify>
Run `npx vitest run` -- all 87 existing tests must still pass (migration code is additive, no behavioral changes to existing functions).
Verify the file compiles: `npx tsc --noEmit`
  </verify>
  <done>
`migrateLocalData` and `hasNonDefaultData` are exported from sync-engine.ts. The function reuses pushToCloud for all 6 localStorage keys. It skips keys with default data, sets a migration-complete localStorage flag on success, and does not set the flag on partial failure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire migration trigger into SyncProvider</name>
  <files>src/sync/SyncContext.tsx</files>
  <action>
Modify `SyncProvider` in `src/sync/SyncContext.tsx` to trigger migration after first authentication:

1. Add import: `import { migrateLocalData } from './sync-engine';` (add to existing import from sync-engine)
2. Add import: `import { useAuth } from '../auth/useAuth';`
3. Inside `SyncProvider` component body, add:
   - `const { user } = useAuth();`
   - `const hasMigrated = useRef(false);`
4. Add a useEffect that:
   - Guards: `if (!user || hasMigrated.current) return;`
   - Checks: `if (localStorage.getItem('migration-complete') === 'true') { hasMigrated.current = true; return; }`
   - Sets a 3-second timeout (allows useCloudStorage pull-on-mount effects to complete first)
   - Inside the timeout callback:
     - Sets `hasMigrated.current = true`
     - Calls `await migrateLocalData((status) => reportStatus('__migration__', status))`
   - Returns cleanup function that clears the timeout
   - Dependencies: `[user, reportStatus]`

The 3-second delay is intentional per research: useCloudStorage hooks fire pullFromCloud on mount for each key. The pulls are simple GET requests that complete quickly. The delay ensures that if the cloud already has data (migrated on another device), it gets pulled into localStorage before migration checks run. Since pullFromCloud leaves localStorage alone when cloud is empty, this timing prevents overwriting cloud data with stale local data.

The `'__migration__'` key for reportStatus integrates migration status into the existing sync status aggregation. During migration the header indicator shows "Syncing..." and afterward shows "Synced" -- the same UX as normal sync operations.

Do NOT create a separate MigrationProvider. Keep all sync-related logic in SyncProvider.
Do NOT modify useCloudStorage.ts or any domain hooks.
  </action>
  <verify>
Run `npx vitest run` -- all 87 existing tests must still pass.
Run `npx tsc --noEmit` -- no type errors.
Verify SyncContext.tsx imports migrateLocalData and useAuth correctly.
  </verify>
  <done>
SyncProvider triggers migrateLocalData 3 seconds after user authenticates. Migration uses the existing reportStatus to show status in the sync indicator. The hasMigrated ref and migration-complete localStorage flag prevent re-runs. Brand-new users with only default data skip migration immediately.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run` -- all existing tests pass (migration is additive, no breaking changes)
2. `npx tsc --noEmit` -- project compiles cleanly
3. Manual verification flow (for when deployed):
   - Start with v1.0 data in localStorage (roster with players, some game history)
   - Sign in for the first time
   - Wait ~3 seconds, observe sync indicator show "Syncing..." then "Synced"
   - Check cloud account via API: roster, gameConfig, gameHistory all present
   - Refresh page: data persists (pulled from cloud)
   - Clear migration-complete flag, refresh: migration runs again idempotently (no duplicates)
</verification>

<success_criteria>
- migrateLocalData() exported from sync-engine.ts, reusing pushToCloud for all 6 keys
- hasNonDefaultData() correctly identifies real user data vs hook defaults for all 6 keys
- SyncProvider triggers migration 3s after first auth, with migration-complete flag preventing re-runs
- Brand-new users (defaults only) skip migration instantly
- Partial failure leaves migration-complete unset so it retries next time
- All 87 existing tests pass, zero new type errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-data-migration/08-01-SUMMARY.md`
</output>
