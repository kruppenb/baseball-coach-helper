---
phase: 04-history-and-output
plan: 05
type: execute
wave: 3
depends_on: ["04-01", "04-04"]
files_modified:
  - src/logic/lineup-generator.ts
  - src/logic/lineup-generator.test.ts
  - src/hooks/useLineup.ts
  - src/components/lineup/LineupPage.tsx
autonomous: true

must_haves:
  truths:
    - "Players who have sat on the bench more in past games get soft priority for field time in new lineups"
    - "Lineup generation still works correctly when there is no history (new season)"
    - "Cross-game fairness does not break any existing lineup constraints"
  artifacts:
    - path: "src/logic/lineup-generator.ts"
      provides: "Updated generateLineup accepting fairness weights"
      exports: ["generateLineup", "generateMultipleLineups"]
    - path: "src/hooks/useLineup.ts"
      provides: "useLineup wires game history into lineup generation"
      contains: "useGameHistory"
  key_links:
    - from: "src/hooks/useLineup.ts"
      to: "src/hooks/useGameHistory.ts"
      via: "reads history for fairness computation"
      pattern: "useGameHistory"
    - from: "src/hooks/useLineup.ts"
      to: "src/logic/game-history.ts"
      via: "calls computeFieldingFairness"
      pattern: "computeFieldingFairness"
    - from: "src/logic/lineup-generator.ts"
      to: "GenerateLineupInput"
      via: "extended input type with optional benchPriority"
      pattern: "benchPriority"
---

<objective>
Integrate cross-game fairness into lineup generation so players who have sat on the bench more in past games get soft priority for field time.

Purpose: This completes HIST-05. Without this, the lineup generator treats every game as independent. With this, coaches get fairer rotation across the season -- kids who sat more previously are prioritized for playing time. The approach uses bench-time balancing (players with more cumulative bench innings are ordered first during position assignment).
Output: Updated lineup generator accepting bench priority weights, useLineup wired to pass history-derived fairness data.
</objective>

<execution_context>
@C:/Users/nicho/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicho/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-history-and-output/04-RESEARCH.md
@.planning/phases/04-history-and-output/04-01-SUMMARY.md
@.planning/phases/04-history-and-output/04-04-SUMMARY.md

@src/types/index.ts
@src/logic/lineup-generator.ts
@src/logic/lineup-types.ts
@src/hooks/useLineup.ts
@src/logic/game-history.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add bench priority to lineup generator</name>
  <files>src/logic/lineup-generator.ts, src/logic/lineup-types.ts, src/logic/lineup-generator.test.ts</files>
  <action>
    1. Update GenerateLineupInput in lineup-types.ts:
       - Add optional field: `benchPriority?: Record<string, number>` -- maps playerId to cumulative bench innings from history. Higher number = player should get MORE field time (sat more in past).

    2. Update lineup-generator.ts attemptBuild function:
       - After the initial shuffle of presentPlayers, if benchPriority is provided, sort the shuffled player list so players with HIGHER benchPriority values come first. This gives them first pick at positions. Use a stable sort that preserves the shuffle order for players with equal priority (break ties randomly).
       - Specifically: replace `const shuffledPlayers = shuffle(presentPlayers)` with:
         ```
         let shuffledPlayers = shuffle(presentPlayers);
         if (input.benchPriority) {
           const bp = input.benchPriority;
           shuffledPlayers.sort((a, b) => (bp[b.id] ?? 0) - (bp[a.id] ?? 0));
         }
         ```
       - This is a SOFT preference: players with more bench history get ordered first, which means they are assigned to infield and field positions before others. The existing constraint solver still ensures all rules are met.

    3. Add tests to lineup-generator.test.ts:
       - Test that generateLineup still works when benchPriority is undefined (backward compatible).
       - Test that generateLineup still works when benchPriority is an empty object.
       - Test that with benchPriority provided, the player with the highest bench count is NOT on the bench in the generated lineup (or at least has fewer bench innings than without priority). This is a statistical test -- run 10 generations and verify the high-priority player sits less on average.
       - Actually, a simpler approach: create a scenario where benchPriority clearly influences ordering. With 10 players and 6 innings, verify that a player with benchPriority of 10 sits on the bench 0 times in a generated lineup (or very rarely). This may need a few attempts since the generator is randomized.

    Note: The sort after shuffle approach means benchPriority acts as a tiebreaker preference, not an absolute constraint. The generator's existing constraint solver (consecutive bench, infield minimums, position blocks) still has final say. This keeps the system robust.
  </action>
  <verify>
    - `npx vitest run src/logic/lineup-generator.test.ts` passes all tests (old + new)
    - `npx tsc --noEmit` compiles
  </verify>
  <done>Lineup generator accepts optional benchPriority in input. Players with higher cumulative bench time are ordered first during position assignment. All existing constraints still enforced. Backward compatible (works without benchPriority).</done>
</task>

<task type="auto">
  <name>Task 2: Wire game history into useLineup for cross-game fairness</name>
  <files>src/hooks/useLineup.ts, src/components/lineup/LineupPage.tsx</files>
  <action>
    1. Update useLineup.ts:
       - Import useGameHistory from './useGameHistory'.
       - Import computeFieldingFairness from '../logic/game-history'.
       - Inside useLineup, call useGameHistory() to get `{ history }`.
       - Compute benchPriority using useMemo:
         ```
         const benchPriority = useMemo(() => {
           if (history.length === 0) return undefined;
           const presentIds = presentPlayers.map(p => p.id);
           const fairness = computeFieldingFairness(history, presentIds);
           const priority: Record<string, number> = {};
           for (const [id, metrics] of Object.entries(fairness)) {
             priority[id] = metrics.totalBenchInnings;
           }
           return priority;
         }, [history, presentPlayers]);
         ```
       - Pass benchPriority into the generate function's input object:
         ```
         const input = {
           presentPlayers,
           innings,
           pitcherAssignments: cleanState.pitcherAssignments,
           catcherAssignments: cleanState.catcherAssignments,
           positionBlocks: cleanState.positionBlocks,
           benchPriority,
         };
         ```
       - This flows through to generateMultipleLineups -> generateLineup -> attemptBuild.

    2. No changes needed to LineupPage.tsx for this task (useLineup handles everything internally). But verify it still renders correctly.

    Note: When history is empty (first game of season), benchPriority is undefined and the generator behaves exactly as before. As games accumulate, fairness metrics automatically influence generation.
  </action>
  <verify>
    - `npx tsc --noEmit` compiles
    - `npx vitest run` all tests pass
    - Dev server: Generate lineups with no history -- works as before
    - Dev server: Finalize a game, then generate new lineups -- generation still works (no errors)
  </verify>
  <done>useLineup reads game history and computes bench priority. Lineup generation automatically factors in cross-game fairness when history exists. No impact when history is empty.</done>
</task>

</tasks>

<verification>
- Lineup generation works with no history (backward compatible)
- Lineup generation works with history (benchPriority passed through)
- Players with more past bench time get soft priority for field positions
- All existing lineup constraints still enforced
- `npx vitest run` and `npx tsc --noEmit` pass
</verification>

<success_criteria>
- HIST-05 complete: lineup generation factors in history for cross-game fairness
- Cross-game fairness uses bench-time balancing (simple, effective)
- No regressions in lineup generation quality or constraint satisfaction
- Works seamlessly for first game (no history) and subsequent games (with history)
</success_criteria>

<output>
After completion, create `.planning/phases/04-history-and-output/04-05-SUMMARY.md`
</output>
