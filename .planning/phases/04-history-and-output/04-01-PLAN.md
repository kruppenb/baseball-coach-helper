---
phase: 04-history-and-output
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/types/index.ts
  - src/logic/game-history.ts
  - src/logic/game-history.test.ts
autonomous: true

must_haves:
  truths:
    - "createGameHistoryEntry produces a complete snapshot of a finalized game"
    - "computeFieldingFairness returns cumulative bench-time per player across all history"
    - "History entries store playerName alongside playerId for robustness against roster deletion"
  artifacts:
    - path: "src/types/index.ts"
      provides: "GameHistoryEntry, PlayerGameSummary types"
      contains: "GameHistoryEntry"
    - path: "src/logic/game-history.ts"
      provides: "createGameHistoryEntry, computeFieldingFairness pure functions"
      exports: ["createGameHistoryEntry", "computeFieldingFairness"]
    - path: "src/logic/game-history.test.ts"
      provides: "Tests for game history logic"
      min_lines: 40
  key_links:
    - from: "src/logic/game-history.ts"
      to: "src/types/index.ts"
      via: "import types"
      pattern: "import.*GameHistoryEntry.*from.*types"
---

<objective>
Create the game history data model and pure logic functions with TDD.

Purpose: Define how finalized game data is structured and provide functions to create history entries and compute cross-game fairness metrics. These are the foundation for the Finalize Game flow (Plan 04) and cross-game fairness integration (Plan 05).
Output: GameHistoryEntry/PlayerGameSummary types in index.ts, createGameHistoryEntry and computeFieldingFairness functions in game-history.ts with full test coverage.
</objective>

<execution_context>
@C:/Users/nicho/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicho/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-history-and-output/04-RESEARCH.md

@src/types/index.ts
@src/logic/batting-order.ts
</context>

<feature>
  <name>Game History Data Model and Logic</name>
  <files>src/types/index.ts, src/logic/game-history.ts, src/logic/game-history.test.ts</files>
  <behavior>
    createGameHistoryEntry(lineup, battingOrder, innings, players):
    - Input: a Lineup (Record of inning -> position -> playerId), battingOrder (string[] of player IDs), innings (5|6), players (Player[])
    - Output: GameHistoryEntry with id (UUID), gameDate (ISO string), innings, lineup (raw), battingOrder (raw), and playerSummaries (computed)
    - Each PlayerGameSummary has: playerId, playerName, battingPosition (index in order), fieldingPositions (Position[] with 'BENCH' for bench innings is NOT used -- instead track benchInnings count separately), benchInnings (count)
    - Only present players get summaries
    - A player on bench in an inning = not assigned to any position in that inning's lineup

    computeFieldingFairness(history, presentPlayerIds):
    - Input: GameHistoryEntry[], string[] of current present player IDs
    - Output: Record<string, { totalBenchInnings: number; positionsPlayed: Position[] }>
    - Sums benchInnings across all history entries per player
    - Collects all unique positions played across history per player
    - Skips players not in presentPlayerIds (handles roster deletions gracefully)
    - Returns empty metrics (0 bench, empty positions) for players with no history

    Cases:
    - 10 players, 6 innings, 1 benched per inning -> each summary has correct benchInnings
    - Player assigned P inning 1, SS inning 2, bench inning 3 -> fieldingPositions = ['P', 'SS'], benchInnings = 1 (for 3-inning subset)
    - computeFieldingFairness with 2 games -> sums bench innings across both
    - computeFieldingFairness skips deleted players not in presentPlayerIds
    - computeFieldingFairness returns {totalBenchInnings: 0, positionsPlayed: []} for new player with no history
  </behavior>
  <implementation>
    Types to add to src/types/index.ts:
    - PlayerGameSummary: { playerId: string; playerName: string; battingPosition: number; fieldingPositions: Position[]; benchInnings: number }
    - GameHistoryEntry: { id: string; gameDate: string; innings: number; lineup: Lineup; battingOrder: string[]; playerSummaries: PlayerGameSummary[] }

    In src/logic/game-history.ts:
    - createGameHistoryEntry: iterate each inning, for each present player find which position they play (check all POSITIONS in lineup[inn]), if none found increment benchInnings. Use crypto.randomUUID() for id, new Date().toISOString() for gameDate.
    - computeFieldingFairness: iterate history entries, for each playerSummary matching a presentPlayerId, accumulate totalBenchInnings and collect unique positions. Initialize all presentPlayerIds with zero metrics first.
  </implementation>
</feature>

<verification>
- `npx vitest run src/logic/game-history.test.ts` passes all tests
- `npx vitest run` passes (no regressions)
- TypeScript compiles: `npx tsc --noEmit`
</verification>

<success_criteria>
- GameHistoryEntry and PlayerGameSummary types exported from src/types/index.ts
- createGameHistoryEntry produces correct playerSummaries for a 10-player, 6-inning game
- computeFieldingFairness correctly sums bench time across multiple games
- computeFieldingFairness handles missing players and new players gracefully
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-history-and-output/04-01-SUMMARY.md`
</output>
