---
phase: 11-drag-and-drop-editing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - package-lock.json
  - src/hooks/useLineupEditor.ts
  - src/components/lineup/DraggableLineupGrid.tsx
  - src/components/lineup/DraggableLineupGrid.module.css
  - src/components/lineup/DraggableCell.tsx
autonomous: true

must_haves:
  truths:
    - "useLineupEditor hook produces a mutable copy of a lineup with swapPositions and real-time validationErrors"
    - "DraggableLineupGrid renders one draggable cell per position per inning with drag handles"
    - "Dragging a cell onto another cell within the same inning triggers a swap via onSwap callback"
    - "Drops across different innings are rejected (same-inning constraint enforced)"
    - "Drag handles have touch-action: none so mobile scrolling is preserved"
  artifacts:
    - path: "src/hooks/useLineupEditor.ts"
      provides: "Mutable lineup editing layer with validation on every change"
      exports: ["useLineupEditor"]
    - path: "src/components/lineup/DraggableLineupGrid.tsx"
      provides: "DnD-enabled fielding grid with DragDropProvider and DragOverlay"
      exports: ["DraggableLineupGrid"]
    - path: "src/components/lineup/DraggableCell.tsx"
      provides: "Individual draggable+droppable grid cell with drag handle"
      exports: ["DraggableCell"]
    - path: "src/components/lineup/DraggableLineupGrid.module.css"
      provides: "Styles for DnD grid including drag handle, drop target, overlay"
  key_links:
    - from: "src/hooks/useLineupEditor.ts"
      to: "src/logic/lineup-validator.ts"
      via: "validateLineup() called in useMemo on every lineup change"
      pattern: "validateLineup\\(editedLineup"
    - from: "src/components/lineup/DraggableCell.tsx"
      to: "@dnd-kit/react"
      via: "useDraggable and useDroppable hooks with handleRef"
      pattern: "useDraggable|useDroppable"
    - from: "src/components/lineup/DraggableLineupGrid.tsx"
      to: "@dnd-kit/react"
      via: "DragDropProvider wrapping the grid with onDragEnd swap handler"
      pattern: "DragDropProvider"
---

<objective>
Install @dnd-kit/react, create the useLineupEditor hook for mutable lineup editing with real-time validation, and build the DraggableLineupGrid component for fielding position swaps via drag-and-drop.

Purpose: Provides the foundation for DND-01 (fielding grid swap), DND-03 (real-time validation), and DND-04 (mobile drag handles) for the fielding grid. The useLineupEditor hook will also be reused by Plan 02 for batting order integration.

Output: Installed @dnd-kit packages, useLineupEditor hook, DraggableLineupGrid + DraggableCell components with CSS.
</objective>

<execution_context>
@C:/Users/nicho/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicho/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-drag-and-drop-editing/11-RESEARCH.md
@src/types/index.ts
@src/logic/lineup-types.ts
@src/logic/lineup-validator.ts
@src/components/lineup/LineupGrid.tsx
@src/components/lineup/LineupGrid.module.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @dnd-kit packages and create useLineupEditor hook</name>
  <files>
    package.json
    package-lock.json
    src/hooks/useLineupEditor.ts
  </files>
  <action>
1. Install @dnd-kit/react and @dnd-kit/helpers pinned to tilde ranges (patch-only updates per research recommendation for pre-1.0 stability):
   ```bash
   npm install @dnd-kit/react@~0.2.4 @dnd-kit/helpers@~0.2.4
   ```
   Verify both appear in package.json dependencies section (not devDependencies).

2. Create `src/hooks/useLineupEditor.ts` — a mutable editing layer that wraps a generated lineup for DnD editing:

   - Import: `useState`, `useMemo`, `useCallback` from React
   - Import: `validateLineup` from `../logic/lineup-validator`
   - Import types: `Lineup`, `Position` from `../types/index`; `GenerateLineupInput`, `ValidationError` from `../logic/lineup-types`

   - `useLineupEditor(initialLineup: Lineup | null, validationInput: GenerateLineupInput)` returns:
     - `lineup: Lineup | null` — the mutable edited copy (initialized via `structuredClone(initialLineup)`)
     - `validationErrors: ValidationError[]` — computed via `useMemo(() => editedLineup ? validateLineup(editedLineup, validationInput) : [], [editedLineup, validationInput])`
     - `swapPositions(inning: number, posA: Position, posB: Position): void` — swaps two players within the same inning using `structuredClone` + `setEditedLineup`
     - `reorderBattingOrder(newOrder: string[]): void` — sets the batting order state (for Plan 02 to use)
     - `battingOrder: string[] | null` — mutable batting order copy
     - `setBattingOrder(order: string[] | null): void` — initializer for batting order
     - `hasEdits: boolean` — true if lineup or batting order differs from initial values (use a `useRef` to store initial values for comparison)
     - `reset(): void` — resets edited lineup and batting order back to initial values

   - When `initialLineup` changes (new lineup selected or generated), reset the edited state. Use a `useEffect` that watches `initialLineup` and calls `setEditedLineup(initialLineup ? structuredClone(initialLineup) : null)`.

   Key behaviors:
   - `swapPositions` must check `posA !== posB` and that `editedLineup[inning]` exists before swapping
   - `validationErrors` recomputes synchronously on every state change (9 positions x 6 innings = trivial computation)
   - The hook does NOT persist changes — it holds a local mutable copy. Persistence happens when the user finalizes the game (handled in ReviewStep)
  </action>
  <verify>
    Run `npm ls @dnd-kit/react` — should show ~0.2.4.
    Run `npx tsc --noEmit` — no type errors.
    Run `npm test` — all existing tests pass (no regressions).
  </verify>
  <done>
    @dnd-kit/react and @dnd-kit/helpers installed at ~0.2.4. useLineupEditor hook exports swapPositions, validationErrors, reorderBattingOrder, battingOrder, hasEdits, reset. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build DraggableLineupGrid and DraggableCell components</name>
  <files>
    src/components/lineup/DraggableCell.tsx
    src/components/lineup/DraggableLineupGrid.tsx
    src/components/lineup/DraggableLineupGrid.module.css
  </files>
  <action>
1. Create `src/components/lineup/DraggableCell.tsx`:
   - Import `useDraggable` and `useDroppable` from `@dnd-kit/react`
   - Import types: `Position` from `../../types/index`

   Props interface `DraggableCellProps`:
   - `inning: number`
   - `position: Position`
   - `playerId: string`
   - `playerName: string`
   - `hasError: boolean`

   Implementation:
   - `useDraggable({ id: \`drag-\${inning}-\${position}\`, data: { inning, position, playerId, playerName } })` — destructure `ref` as `dragRef`, `handleRef`, `isDragSource`
   - `useDroppable({ id: \`drop-\${inning}-\${position}\`, data: { inning, position, playerId }, accept: (source) => source?.data?.inning === inning })` — destructure `ref` as `dropRef`, `isDropTarget`
   - The `accept` function (named `accepts` in dnd-kit API) restricts drops to same-inning only (DND-01 requirement)
   - Render structure:
     ```
     <div ref={dropRef} className={cell class + dropTarget highlight + error highlight}>
       <div ref={dragRef} className={draggable wrapper + isDragSource opacity}>
         <span ref={handleRef} className={dragHandle} aria-label="Drag to swap position">
           &#x2630;
         </span>
         <span className={playerName}>{playerName}</span>
       </div>
     </div>
     ```
   - When `isDragSource` is true, apply reduced opacity (0.4) to indicate the dragged item
   - When `isDropTarget` is true, apply a highlight border/background to indicate valid drop zone

2. Create `src/components/lineup/DraggableLineupGrid.tsx`:
   - Import `DragDropProvider` and `DragOverlay` from `@dnd-kit/react`
   - Import `DraggableCell` from `./DraggableCell`
   - Import types: `Lineup`, `Player`, `Position` from `../../types/index`; `ValidationError` from `../../logic/lineup-types`
   - Import `POSITIONS` from `../../types/index`

   Props interface `DraggableLineupGridProps`:
   - `lineup: Lineup`
   - `innings: number`
   - `players: Player[]`
   - `errors: ValidationError[]`
   - `onSwap: (inning: number, posA: Position, posB: Position) => void`

   Reuse the `getPlayerName` and `hasError` helper functions from the existing `LineupGrid.tsx` (copy them — these are small pure functions, not worth extracting to a shared module).

   Implementation:
   - Wrap entire grid in `<DragDropProvider onDragEnd={handleDragEnd}>` where `handleDragEnd`:
     1. Check `if (event.canceled) return;` FIRST (Pitfall 3 from research)
     2. Extract `source` and `target` from `event.operation`
     3. If no target, return
     4. Extract `position` from `source.data` and `target.data`
     5. Verify both positions exist and are different
     6. Call `onSwap(source.data.inning, source.data.position, target.data.position)`
   - Render the same grid layout as `LineupGrid.tsx` (CSS Grid with `gridTemplateColumns: auto repeat(N, 1fr)`), but replacing the read-only cells with `<DraggableCell>` components
   - Keep the header row (Inn 1, Inn 2, ...) and position label column (P, C, 1B, ...) identical to LineupGrid
   - Keep the bench row read-only (not draggable) — per research, field-to-field swaps only for MVP
   - Add `<DragOverlay>` inside the provider with a function child that renders a styled overlay showing the player name being dragged:
     ```tsx
     <DragOverlay>
       {(source) => source ? (
         <div className={styles.dragOverlay}>
           {source.data?.playerName ?? ''}
         </div>
       ) : null}
     </DragOverlay>
     ```

3. Create `src/components/lineup/DraggableLineupGrid.module.css`:
   - Import/reuse the same CSS custom properties (--color-*, --space-*, --font-size-*, --radius-*, --min-tap-size)
   - `.grid` — same as LineupGrid.module.css .grid
   - `.cornerCell`, `.headerCell`, `.positionLabel`, `.benchLabel`, `.benchCell` — same as LineupGrid.module.css
   - `.cell` — same base as LineupGrid .cell
   - `.errorCell` — same as LineupGrid .errorCell
   - `.dropTarget` — add `background: var(--color-primary-light, #dbeafe); outline: 2px dashed var(--color-primary);` to indicate valid drop zone
   - `.draggableWrapper` — `display: flex; align-items: center; gap: var(--space-xs); width: 100%;`
   - `.dragging` — `opacity: 0.4;`
   - `.dragHandle` — `touch-action: none; cursor: grab; padding: var(--space-xs); color: var(--color-text-muted); user-select: none; display: flex; align-items: center; font-size: var(--font-size-base);`
   - `.dragHandle:active` — `cursor: grabbing;`
   - `.playerName` — `font-size: var(--font-size-sm);`
   - `.dragOverlay` — `background: white; border: 2px solid var(--color-primary); border-radius: var(--radius-md); padding: var(--space-sm) var(--space-md); font-size: var(--font-size-sm); font-weight: 600; box-shadow: 0 4px 12px rgba(0,0,0,0.15);`
  </action>
  <verify>
    Run `npx tsc --noEmit` — no type errors.
    Run `npm test` — all existing tests pass.
    Verify that `DraggableLineupGrid` and `DraggableCell` export correctly: `grep -r "export function Draggable" src/components/lineup/`
  </verify>
  <done>
    DraggableCell renders each grid position as a draggable+droppable element with a drag handle (touch-action: none for mobile). DraggableLineupGrid wraps the grid in a DragDropProvider, handles onDragEnd swaps within same inning only, renders DragOverlay during drag, and keeps bench row read-only. Both components type-check cleanly.
  </done>
</task>

</tasks>

<verification>
- `npm ls @dnd-kit/react @dnd-kit/helpers` shows both installed at ~0.2.4
- `npx tsc --noEmit` passes with zero errors
- `npm test` passes with no regressions
- `DraggableLineupGrid` and `DraggableCell` exist and export correctly
- `useLineupEditor` hook exists and exports correctly
</verification>

<success_criteria>
- @dnd-kit/react ~0.2.4 and @dnd-kit/helpers ~0.2.4 installed as production dependencies
- useLineupEditor hook provides mutable lineup editing with swapPositions, real-time validationErrors via validateLineup(), battingOrder state, hasEdits flag, and reset
- DraggableLineupGrid renders a CSS grid with DraggableCell for each position slot
- DraggableCell uses useDraggable + useDroppable with same-inning accept filter
- Drag handles have touch-action: none (DND-04 mobile support)
- DragOverlay shows player name during drag
- Bench row remains read-only
- All existing tests pass, TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/11-drag-and-drop-editing/11-01-SUMMARY.md`
</output>
