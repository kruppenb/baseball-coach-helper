---
phase: 11-drag-and-drop-editing
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - src/components/batting-order/SortableBattingOrder.tsx
  - src/components/batting-order/SortableBattingOrder.module.css
  - src/components/batting-order/SortableItem.tsx
  - src/components/game-day/steps/ReviewStep.tsx
  - src/components/game-day/steps/ReviewStep.module.css
autonomous: false

must_haves:
  truths:
    - "Coach can drag batting order entries to reorder them via drag handles"
    - "Coach can drag fielding grid cells to swap positions within an inning"
    - "Constraint violations appear in real-time after every drag edit without page reload"
    - "Drag-and-drop works on mobile touch devices via drag handles without stealing page scroll"
    - "Finalize Game uses the edited lineup and edited batting order (not the original generated ones)"
  artifacts:
    - path: "src/components/batting-order/SortableBattingOrder.tsx"
      provides: "DnD-enabled sortable batting order list"
      exports: ["SortableBattingOrder"]
    - path: "src/components/batting-order/SortableItem.tsx"
      provides: "Individual sortable batting order item with drag handle"
      exports: ["SortableItem"]
    - path: "src/components/batting-order/SortableBattingOrder.module.css"
      provides: "Styles for sortable list including drag handle and dragging state"
    - path: "src/components/game-day/steps/ReviewStep.tsx"
      provides: "Integration point: DnD grid + sortable batting order + useLineupEditor + finalize with edited data"
  key_links:
    - from: "src/components/batting-order/SortableBattingOrder.tsx"
      to: "@dnd-kit/react"
      via: "DragDropProvider with isSortable onDragEnd handler"
      pattern: "DragDropProvider|isSortable"
    - from: "src/components/batting-order/SortableItem.tsx"
      to: "@dnd-kit/react/sortable"
      via: "useSortable hook with handleRef for drag handle"
      pattern: "useSortable"
    - from: "src/components/game-day/steps/ReviewStep.tsx"
      to: "src/hooks/useLineupEditor.ts"
      via: "useLineupEditor provides edited lineup/batting order and swapPositions"
      pattern: "useLineupEditor"
    - from: "src/components/game-day/steps/ReviewStep.tsx"
      to: "src/components/lineup/DraggableLineupGrid.tsx"
      via: "Replaces read-only LineupGrid in review section"
      pattern: "DraggableLineupGrid"
    - from: "ReviewStep handleFinalize"
      to: "finalizeGame"
      via: "Passes editor.lineup and editor.battingOrder instead of selectedLineup and currentOrder"
      pattern: "finalizeGame\\(editor\\.lineup"
---

<objective>
Build the SortableBattingOrder component for drag-and-drop batting order reordering, then wire both DnD components (fielding grid + batting order) into the ReviewStep with useLineupEditor for a complete editing experience.

Purpose: Completes DND-02 (batting order reorder), integrates DND-01 (fielding swap) from Plan 01, ensures DND-03 (real-time validation) is visible in context, and verifies DND-04 (mobile touch). The ReviewStep becomes the central editing hub where coaches can tweak both fielding and batting before finalizing.

Output: SortableBattingOrder + SortableItem components, updated ReviewStep with full DnD integration, checkpoint for visual/functional verification.
</objective>

<execution_context>
@C:/Users/nicho/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicho/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-drag-and-drop-editing/11-RESEARCH.md
@.planning/phases/11-drag-and-drop-editing/11-01-SUMMARY.md
@src/types/index.ts
@src/logic/lineup-types.ts
@src/hooks/useLineupEditor.ts
@src/components/lineup/DraggableLineupGrid.tsx
@src/components/game-day/steps/ReviewStep.tsx
@src/components/game-day/steps/ReviewStep.module.css
@src/components/batting-order/BattingOrderList.tsx
@src/components/batting-order/BattingOrderList.module.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build SortableBattingOrder and SortableItem components</name>
  <files>
    src/components/batting-order/SortableItem.tsx
    src/components/batting-order/SortableBattingOrder.tsx
    src/components/batting-order/SortableBattingOrder.module.css
  </files>
  <action>
1. Create `src/components/batting-order/SortableItem.tsx`:
   - Import `useSortable` from `@dnd-kit/react/sortable`
   - Import styles from `./SortableBattingOrder.module.css` (shared styles)

   Props interface `SortableItemProps`:
   - `id: string` (player ID)
   - `index: number` (current position in the batting order)
   - `name: string` (player display name)

   Implementation:
   - Call `useSortable({ id, index })` — destructure `ref`, `handleRef`, `isDragSource`
   - Render:
     ```tsx
     <li ref={ref} className={`${styles.item} ${isDragSource ? styles.dragging : ''}`}>
       <span ref={handleRef} className={styles.dragHandle} aria-label="Drag to reorder">
         &#x2630;
       </span>
       <span className={styles.position}>{index + 1}</span>
       <span className={styles.name}>{name}</span>
     </li>
     ```

2. Create `src/components/batting-order/SortableBattingOrder.tsx`:
   - Import `DragDropProvider` from `@dnd-kit/react`
   - Import `isSortable` from `@dnd-kit/react/sortable`
   - Import `SortableItem` from `./SortableItem`
   - Import types: `Player` from `../../types/index`

   Props interface `SortableBattingOrderProps`:
   - `order: string[]` (array of player IDs in batting order)
   - `players: Player[]` (for name lookup)
   - `onReorder: (newOrder: string[]) => void` (callback when order changes)

   Implementation:
   - Create a playerMap: `new Map(players.map(p => [p.id, p]))`
   - Wrap the list in `<DragDropProvider onDragEnd={handleDragEnd}>`:
     - `handleDragEnd(event)`:
       1. `if (event.canceled) return;` (Pitfall 3)
       2. Extract `source` from `event.operation`
       3. Check `isSortable(source)` type guard (Pitfall 5 — provides `initialIndex` and `index`)
       4. If `source.initialIndex !== source.index`:
          - Create new order array: `const newOrder = [...order]`
          - `const [removed] = newOrder.splice(source.initialIndex, 1)`
          - `newOrder.splice(source.index, 0, removed)`
          - Call `onReorder(newOrder)`
   - Render:
     ```tsx
     <ol className={styles.list}>
       {order.map((playerId, index) => (
         <SortableItem
           key={playerId}
           id={playerId}
           index={index}
           name={playerMap.get(playerId)?.name ?? 'Unknown'}
         />
       ))}
     </ol>
     ```

3. Create `src/components/batting-order/SortableBattingOrder.module.css`:
   - `.list` — `list-style: none; padding: 0; margin: 0;`
   - `.item` — `display: flex; flex-direction: row; align-items: center; gap: var(--space-md); min-height: var(--min-tap-size); border-bottom: 1px solid var(--color-border); padding: var(--space-sm) 0; transition: background 0.15s ease;` (matches existing BattingOrderList.module.css .item layout)
   - `.dragging` — `opacity: 0.4; background: var(--color-surface);`
   - `.dragHandle` — `touch-action: none; cursor: grab; padding: var(--space-xs); color: var(--color-text-muted); user-select: none; display: flex; align-items: center; font-size: var(--font-size-base); flex-shrink: 0;`
   - `.dragHandle:active` — `cursor: grabbing;`
   - `.position` — `width: 2ch; font-weight: 600; color: var(--color-text-muted); text-align: right; flex-shrink: 0;` (matches existing BattingOrderList .position)
   - `.name` — `flex: 1; font-size: var(--font-size-base);` (matches existing BattingOrderList .name)
  </action>
  <verify>
    Run `npx tsc --noEmit` — no type errors.
    Run `npm test` — all existing tests pass.
    Verify exports: `grep -r "export function Sortable" src/components/batting-order/`
  </verify>
  <done>
    SortableItem renders a sortable list item with drag handle (touch-action: none) and position number. SortableBattingOrder wraps the list in a DragDropProvider, handles reorder via isSortable type guard with initialIndex/index swap, and calls onReorder with the new order. Both components type-check cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire DnD components into ReviewStep with useLineupEditor</name>
  <files>
    src/components/game-day/steps/ReviewStep.tsx
    src/components/game-day/steps/ReviewStep.module.css
  </files>
  <action>
1. Modify `src/components/game-day/steps/ReviewStep.tsx` to integrate DnD editing:

   **New imports:**
   - `import { useLineupEditor } from '../../../hooks/useLineupEditor';`
   - `import { DraggableLineupGrid } from '../../lineup/DraggableLineupGrid';`
   - `import { SortableBattingOrder } from '../../batting-order/SortableBattingOrder';`
   - `import type { GenerateLineupInput } from '../../../logic/lineup-types';`
   - Remove: the `LineupGrid` import (replaced by DraggableLineupGrid)
   - Remove: the `BattingOrderList` import (replaced by SortableBattingOrder)

   **Destructure additional values from useLineup()** — add `pitcherAssignments`, `catcherAssignments`, `positionBlocks` alongside the existing destructured values.

   **Add useLineupEditor hook call** inside the ReviewStep component, after the existing hook calls:
   ```tsx
   const validationInput: GenerateLineupInput = useMemo(() => ({
     presentPlayers: presentPlayers,
     innings,
     pitcherAssignments,
     catcherAssignments,
     positionBlocks,
   }), [presentPlayers, innings, pitcherAssignments, catcherAssignments, positionBlocks]);

   const editor = useLineupEditor(selectedLineup, validationInput);
   ```

   **Initialize batting order in editor** when `currentOrder` changes:
   ```tsx
   useEffect(() => {
     editor.setBattingOrder(currentOrder);
   // eslint-disable-next-line react-hooks/exhaustive-deps
   }, [currentOrder]);
   ```

   **Replace LineupGrid with DraggableLineupGrid** in the lineup grid section:
   ```tsx
   <DraggableLineupGrid
     lineup={editor.lineup!}
     innings={innings}
     players={players}
     errors={editor.validationErrors}
     onSwap={editor.swapPositions}
   />
   ```
   Use `editor.validationErrors` (real-time from edited lineup) instead of `validationErrors` from useLineup.

   **Replace BattingOrderList with SortableBattingOrder** in the batting order section:
   ```tsx
   {editor.battingOrder && (
     <SortableBattingOrder
       order={editor.battingOrder}
       players={battingPresentPlayers}
       onReorder={editor.reorderBattingOrder}
     />
   )}
   ```

   **Update ValidationPanel** to use `editor.validationErrors`:
   ```tsx
   <ValidationPanel errors={editor.validationErrors} preErrors={[]} />
   ```

   **Update FairnessSummary** to use `editor.lineup`:
   ```tsx
   <FairnessSummary
     summary={computeFairnessSummary(editor.lineup!, innings, players)}
   />
   ```

   **Update handleFinalize** to use edited data instead of originals:
   ```tsx
   const handleFinalize = () => {
     if (!editor.lineup || !editor.battingOrder) return;
     confirmBatting();
     finalizeGame(editor.lineup, editor.battingOrder, innings, players);
     setIsFinalized(true);
   };
   ```
   This is the critical wiring — the edited lineup (with drag swaps) and edited batting order (with drag reorder) are what gets saved to history, NOT the original generated values.

   **Update the "Previous Batting Order comparison" section** to use `editor.battingOrder` for the "Current Game" column (so it reflects any reordering the coach has done).

   **Add an "edits indicator"** — if `editor.hasEdits` is true, show a small text label near the heading:
   ```tsx
   {editor.hasEdits && (
     <span className={styles.editsBadge}>Edited</span>
   )}
   ```

2. Modify `src/components/game-day/steps/ReviewStep.module.css`:
   - Add `.editsBadge` — `display: inline-block; background: var(--color-primary); color: white; font-size: var(--font-size-xs, 0.75rem); font-weight: 600; padding: 2px var(--space-sm); border-radius: var(--radius-sm, 4px); margin-left: var(--space-sm); vertical-align: middle;`

   No other CSS changes needed — the DnD components bring their own styles.
  </action>
  <verify>
    Run `npx tsc --noEmit` — no type errors.
    Run `npm test` — all existing tests pass.
    Run `npm run build` — production build succeeds.
    Start dev server with `npm run dev` and visually confirm:
    1. Navigate to Game Day stepper, complete Attendance + P/C Assignment + Generate steps
    2. In Review step, verify drag handles (hamburger icons) appear next to each fielding grid cell
    3. Verify drag handles appear next to each batting order entry
    4. Verify "Edited" badge does NOT appear initially
  </verify>
  <done>
    ReviewStep uses useLineupEditor for mutable editing state. DraggableLineupGrid replaces LineupGrid for fielding DnD swaps. SortableBattingOrder replaces BattingOrderList for batting order DnD reorder. ValidationPanel and FairnessSummary use real-time editor state. Finalize saves edited data. "Edited" badge appears when changes are made. TypeScript compiles, build succeeds.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify drag-and-drop works end-to-end</name>
  <files>n/a</files>
  <action>
    Human verification of all four DND requirements. See how-to-verify below for detailed test steps.
  </action>
  <what-built>
    Complete drag-and-drop editing for both fielding lineup (position swaps within innings) and batting order (reorder). Real-time constraint validation after every edit. Mobile touch support via drag handles.
  </what-built>
  <how-to-verify>
    Start the dev server (`npm run dev`) and open http://localhost:5180

    **Test 1 -- Fielding Grid Swap (DND-01):**
    1. Complete Attendance, P/C Assignment, Generate steps to reach Review
    2. Find the fielding grid -- each cell should show a hamburger drag handle (three horizontal lines)
    3. Drag a player from one position to another within the SAME inning column
    4. Verify the two players swap positions
    5. Verify the "Edited" badge appears near the heading
    6. Try dragging across different innings -- it should NOT allow the drop (visual: no highlight on cross-inning cells)

    **Test 2 -- Batting Order Reorder (DND-02):**
    1. Generate a batting order in the Review step
    2. Drag a batting order entry up or down using its drag handle
    3. Verify the entry moves to the new position and numbers update

    **Test 3 -- Real-Time Validation (DND-03):**
    1. Make a fielding swap that creates a constraint violation (e.g., swap so a player plays the same position in two consecutive innings)
    2. Verify the validation panel updates immediately showing the new error
    3. Swap back -- verify the error disappears

    **Test 4 -- Mobile Touch (DND-04):**
    1. Open Chrome DevTools, toggle device toolbar (mobile view)
    2. Verify you can scroll the page by touching outside the drag handles
    3. Verify you can initiate a drag by touching and holding a drag handle
    4. Complete a swap on mobile -- verify it works

    **Test 5 -- Finalize with Edits:**
    1. Make some edits (swap fielding positions, reorder batting)
    2. Click "Finalize Game"
    3. Proceed to Print step -- verify the dugout card shows the EDITED lineup, not the original generated one
  </how-to-verify>
  <verify>Human confirms all 5 tests pass</verify>
  <done>All four DND requirements (DND-01 through DND-04) verified working by human tester</done>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm test` passes with no regressions
- `npm run build` succeeds
- All four DND requirements verified:
  - DND-01: Fielding grid cells swap within same inning via drag
  - DND-02: Batting order entries reorder via drag
  - DND-03: Validation updates in real-time after every edit
  - DND-04: Touch drag handles work on mobile without breaking scroll
</verification>

<success_criteria>
- SortableBattingOrder with useSortable handles batting order reordering
- ReviewStep integrates DraggableLineupGrid (from Plan 01) and SortableBattingOrder
- useLineupEditor provides mutable state layer between generated lineup and finalization
- Real-time validation errors display in ValidationPanel after every drag edit
- FairnessSummary recalculates after edits
- Finalize Game saves the edited lineup and batting order (not originals)
- "Edited" badge appears when coach makes DnD changes
- Drag handles have touch-action: none for mobile support
- Human verifies all four DND requirements work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/11-drag-and-drop-editing/11-02-SUMMARY.md`
</output>
