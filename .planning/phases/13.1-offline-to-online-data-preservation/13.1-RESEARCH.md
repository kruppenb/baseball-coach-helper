# Phase 13.1: Offline-to-Online Data Preservation - Research

**Researched:** 2026-02-15
**Domain:** Sync conflict detection across auth boundaries, localStorage dirty tracking persistence
**Confidence:** HIGH

## Summary

This phase fixes a data loss bug where local changes made while logged out are silently overwritten when the coach logs in. The root cause is well-understood and localized: the Phase 13 conflict detection system relies on in-memory state (`dirtyKeys`, `pulledKeys`, `etagStore` -- all module-level `Set`/`Map` objects in `sync-engine.ts`) that resets on every page load. Login via SWA's `/.auth/login/aad` causes a full-page redirect and reload, wiping all in-memory sync state. When `useCloudStorage` hooks fire their pull-on-mount effect after authentication, the fresh `pullFromCloud` finds `dirtyKeys` empty and `pulledKeys` empty, so it unconditionally overwrites localStorage with cloud data -- destroying the coach's offline edits.

The fix requires detecting that localStorage contains meaningful offline edits *before* the first pull happens after login. This is a data-comparison problem, not an ETag problem -- there is no ETag for offline edits because no cloud interaction occurred. The existing `hasNonDefaultData()` function in `sync-engine.ts` already knows how to check whether a localStorage key contains real user data vs. defaults. The solution is to compare local data against cloud data during the pull and, when they differ, surface the existing ConflictDialog instead of silently overwriting.

**Primary recommendation:** Modify `pullFromCloud` to compare fetched cloud data against existing localStorage data before overwriting. When both sides have non-default data that differs, invoke an `onConflict` callback (same pattern as the 412 push path) to trigger the ConflictDialog. This reuses 100% of the existing conflict resolution UI and logic from Phase 13.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| React | ^19.2.0 | UI framework (existing) | Already installed |
| Native `<dialog>` | N/A | ConflictDialog (existing from Phase 13) | Already built, reused as-is |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| None needed | - | - | Fix is pure application logic in existing files |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Comparing data in pullFromCloud | Persisting dirtyKeys to localStorage | Adds complexity; dirtyKeys was designed as ephemeral; comparing data is more reliable since it catches the actual state |
| JSON.stringify comparison | Deep equality library (lodash.isEqual) | JSON.stringify is sufficient for these data shapes (no functions, no circular refs, no Maps); no new dependency needed |
| Pull-time conflict detection | Pre-login localStorage snapshot | Snapshot would require hooking into the login link click, fragile with SWA redirect flow, doesn't handle session timeout re-auth |

**Installation:**
```bash
# No new packages needed
```

## Architecture Patterns

### Root Cause Analysis

The bug exists because of a state gap across the login redirect boundary:

```
BEFORE LOGIN (logged out):
  - Coach edits roster → localStorage["roster"] = [...]
  - useCloudStorage returns setLocalValue (no cloud push, user is null)
  - dirtyKeys: empty (no one calls markDirty when !user)
  - etagStore: empty (no cloud interaction)

LOGIN REDIRECT:
  - Browser navigates to /.auth/login/aad → Entra ID → redirect back
  - FULL PAGE RELOAD: all in-memory state destroyed

AFTER LOGIN (authenticated):
  - AuthContext fetches /.auth/me → user is now set
  - useCloudStorage effect fires: pullFromCloud(key, ...)
  - pullFromCloud checks: pulledKeys.has(key)? NO. dirtyKeys.has(key)? NO.
  - pullFromCloud fetches cloud data → OVERWRITES localStorage
  - Coach's offline edits are gone. No dialog shown.
```

### Why Existing Guards Fail

1. **`dirtyKeys` guard:** Empty because it's a module-level `Set` that resets on page reload. Even if it were populated before login, the redirect wipes it.

2. **`pulledKeys` guard:** Same problem -- empty after page reload.

3. **`etagStore`:** Empty -- no cloud interaction happened while logged out, so no ETag was ever stored.

4. **`migration-complete` flag:** If the user has logged in before, this is `'true'` in localStorage, so the migration logic in SyncContext is skipped entirely. Even if it runs, it runs on a 3-second delay -- the pull has already overwritten local data by then.

5. **Phase 13 ETag conflict detection:** Only works on the **push** path (If-Match → 412 from API). The overwrite happens on the **pull** path, which has no conflict detection.

### Fix Architecture

```
pullFromCloud (MODIFIED):
  1. Fetch cloud data via GET
  2. NEW: Before overwriting localStorage, check if local data exists and differs
     a. Read current localStorage[key]
     b. If local data is non-default AND cloud data is non-default AND they differ:
        → Call onConflict({key, localData, cloudData, cloudEtag, ...})
        → Do NOT overwrite localStorage
        → Mark key in pulledKeys to prevent duplicate pulls
        → Return (let ConflictDialog handle resolution)
     c. If local data is default/empty OR matches cloud data:
        → Proceed with normal overwrite (existing behavior)
  3. Rest of existing logic unchanged
```

### Key Design Decisions to Make

#### 1. Where to detect the conflict
**Recommendation: Inside `pullFromCloud` in `sync-engine.ts`**

The pull function already has the cloud data and access to localStorage. Adding the comparison here is the minimal, surgical change. It avoids modifying useCloudStorage, SyncContext, or the ConflictDialog at all.

#### 2. How to compare local vs. cloud data
**Recommendation: `JSON.stringify` comparison**

The data shapes are simple JSON (arrays of player objects, config objects, lineup state). `JSON.stringify` is deterministic for these shapes (no Maps, Sets, functions, or circular references). It's already used for comparison elsewhere in the codebase (Phase 11 `useLineupEditor` uses `JSON.stringify` for `hasEdits`).

#### 3. What qualifies as "local data worth preserving"
**Recommendation: Reuse `hasNonDefaultData(key)` from `sync-engine.ts`**

This function already knows the schema of each sync key and distinguishes real data from defaults. If `hasNonDefaultData(key)` returns false, the local data is just the initial value and can be safely overwritten by cloud data.

#### 4. How to get onConflict callback into pullFromCloud
**Recommendation: Add optional `onConflict` parameter to `pullFromCloud`**

`pullFromCloud` currently has signature `(key, config, onStatus)`. Add `onConflict?: (info: ConflictInfo) => void` as a fourth parameter, matching the pattern already used in `pushToCloud` and `debouncedPush`.

Then update `useCloudStorage` to pass `onConflict` through to `pullFromCloud`:
```typescript
// In useCloudStorage, the pull effect:
useEffect(() => {
  if (!user) return;
  pullFromCloud(key, apiConfigRef.current,
    (status) => reportStatus(key, status),
    onConflict  // NEW: pass through from SyncContext
  );
}, [key, user, reportStatus, onConflict]);
```

#### 5. What about the migration path
**Recommendation: No changes needed to migration logic**

The migration runs only once (gated by `migration-complete` localStorage flag). For users who have already migrated, it's skipped. For new users with only default data, `hasNonDefaultData` returns false, so the pull proceeds normally. The migration path is orthogonal to this bug.

### Modified File Map
```
src/sync/
  sync-engine.ts       # MODIFY: pullFromCloud gets onConflict param + local-vs-cloud comparison
  useCloudStorage.ts   # MODIFY: Pass onConflict to pullFromCloud in pull effect
```

That's it. Two files, minimal changes.

### Pattern: Pull-Time Conflict Detection
**What:** Before overwriting localStorage during a cloud pull, compare fetched data against existing local data. If both are non-default and differ, trigger conflict resolution instead of overwriting.
**When to use:** Every pull that could overwrite meaningful local data -- specifically the first pull after login.
**Example:**
```typescript
// In pullFromCloud, after fetching cloud data but before writing to localStorage:
export async function pullFromCloud(
  key: string,
  config: SyncKeyConfig,
  onStatus: (status: SyncStatus) => void,
  onConflict?: (info: ConflictInfo) => void,
): Promise<void> {
  // ... existing guards (pulledKeys, dirtyKeys) ...
  // ... fetch cloud data ...

  if (config.mode === 'singleton') {
    const cloudEtag = typeof json._etag === 'string' ? json._etag : null;
    const data = config.responseKey ? json[config.responseKey] : json.data;

    if (data !== null && data !== undefined) {
      // Skip empty-object defaults from cloud
      if (typeof data === 'object' && !Array.isArray(data) && Object.keys(data).length === 0) {
        onStatus('synced');
        return;
      }

      // NEW: Check for local-vs-cloud conflict before overwriting
      if (onConflict && hasNonDefaultData(key)) {
        const localRaw = localStorage.getItem(key);
        if (localRaw !== null) {
          const localData = JSON.parse(localRaw);
          const cloudStr = JSON.stringify(data);
          const localStr = JSON.stringify(localData);
          if (cloudStr !== localStr) {
            // Conflict: local offline edits vs. cloud data
            onConflict({
              key,
              localData,
              cloudData: data,
              cloudEtag,
              cloudUpdatedAt: (json as Record<string, unknown>).updatedAt as string | null ?? null,
            });
            pulledKeys.add(key);
            onStatus('error');
            return;
          }
        }
      }

      // No conflict (or no local data): proceed with normal overwrite
      if (cloudEtag) {
        etagStore.set(key, cloudEtag);
      }
      localStorage.setItem(key, JSON.stringify(data));
      window.dispatchEvent(
        new CustomEvent('local-storage-sync', {
          detail: { key, value: data },
        })
      );
    }
  }
  // ... collection mode unchanged ...

  pulledKeys.add(key);
  onStatus('synced');
}
```

### Anti-Patterns to Avoid
- **Persisting dirtyKeys to localStorage:** Overcomplicates the system. The comparison approach is more robust because it detects the actual state of the data, not whether a flag was set correctly.
- **Blocking the pull entirely when local data exists:** The coach might WANT the cloud data (e.g., they logged out, made no changes, then logged back in). Only block when local and cloud data actually differ.
- **Adding a separate "offline changes detected" dialog:** Reuse the existing ConflictDialog. It already has the right UX (This Device vs. Cloud with timestamps). Adding a second dialog creates UX fragmentation.
- **Trying to hook into the login redirect:** SWA auth uses browser redirects. There's no reliable way to intercept before the redirect to snapshot state. The fix must work at pull time, after the redirect.
- **Comparing only top-level keys:** Use full `JSON.stringify` comparison. Partial comparison (e.g., just checking array length) could miss real conflicts where a player was renamed but the roster length is the same.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Conflict resolution UI | New dialog for pull conflicts | Existing ConflictDialog | Same UX, same code path, same resolution logic |
| Data comparison | Custom deep equality | JSON.stringify comparison | Sufficient for these simple data shapes; already used in codebase |
| Non-default data check | New detection logic | Existing hasNonDefaultData() | Already covers all 6 sync keys with per-key schema knowledge |
| Pull-time conflict callback | New event system | Existing onConflict pattern from pushToCloud | Same ConflictInfo type, same SyncContext handler |

**Key insight:** Phase 13 built all the conflict resolution infrastructure. Phase 13.1 just needs to invoke it from one additional code path (pulls, not just pushes).

## Common Pitfalls

### Pitfall 1: Collection Mode Pull Conflicts
**What goes wrong:** Game history and batting history use collection mode (append-only). Comparing the full collection arrays will always "differ" if the local history has entries not yet synced to cloud.
**Why it happens:** Collection mode data is additive. The local array may have entries the cloud doesn't, which is normal (not a conflict).
**How to avoid:** Only apply pull-time conflict detection to singleton mode keys (roster, gameConfig, lineupState, battingOrderState). Collection mode keys are append-only and already handled correctly by the existing lastSyncedCount tracking.
**Warning signs:** Spurious conflict dialogs appearing for game history when none are expected.

### Pitfall 2: False Conflicts from Property Ordering
**What goes wrong:** JSON.stringify produces different strings for `{a:1, b:2}` vs `{b:2, a:1}` even though they're semantically identical.
**Why it happens:** The cloud may return properties in a different order than how they were stored locally.
**How to avoid:** In practice this is not a problem for this codebase because: (a) localStorage stores data that was JSON.stringify'd from React state, and (b) the cloud returns data that was stored from the same JSON. Property order is preserved through the roundtrip. However, if false conflicts appear in testing, use a sorted-keys comparison: `JSON.stringify(data, Object.keys(data).sort())`.
**Warning signs:** Conflict dialog appearing immediately after login even when no changes were made offline.

### Pitfall 3: Conflict Dialog Appearing for First-Time Users
**What goes wrong:** A brand-new user who has never synced sees a conflict dialog on first login because their local default data differs from the cloud's empty/null response.
**Why it happens:** `hasNonDefaultData` could return true if the user navigated the app before logging in (creating default structures in localStorage that differ from the cloud's null).
**How to avoid:** The check requires BOTH `hasNonDefaultData(key)` to be true AND cloud data to be non-null/non-empty. If the cloud returns null/empty (new user, no data in Cosmos), the existing code path correctly skips the write anyway (`if (data !== null && data !== undefined)`), so no conflict is possible.
**Warning signs:** New users getting conflict dialogs before they've ever saved anything.

### Pitfall 4: ETag Not Stored After Pull-Time Conflict Resolution
**What goes wrong:** After the coach resolves a pull-time conflict, the ETag from the cloud response is not stored. The next push has no If-Match header, bypassing optimistic concurrency.
**Why it happens:** When pullFromCloud returns early (before the normal ETag storage code) to trigger the conflict dialog, the ETag is only in the ConflictInfo. The existing resolveConflict in SyncContext handles this correctly for "Keep Cloud" (calls `setStoredEtag`), and for "Keep This Device" (also calls `setStoredEtag` then re-pushes). But this must be verified.
**How to avoid:** The ConflictInfo already carries `cloudEtag`. The SyncContext resolveConflict function already calls `setStoredEtag(key, cloudEtag)` for both resolution paths. No additional work needed -- just verify this path works for pull-sourced conflicts too.
**Warning signs:** 412 errors on the first push after resolving a pull-time conflict.

### Pitfall 5: Race Between Multiple Singleton Pulls
**What goes wrong:** All 4 singleton keys fire pullFromCloud simultaneously on login. If multiple trigger conflicts, only the first ConflictDialog is shown (SyncContext stores one `activeConflict` at a time).
**Why it happens:** `useCloudStorage` hooks for all keys run their pull effect when `user` changes.
**How to avoid:** This is actually handled correctly by the existing ConflictDialog pattern. When `setActiveConflict` is called while another conflict is active, the previous conflict info is replaced. However, this means only the LAST conflict to arrive gets shown. To handle multiple conflicts, the system would need a queue. For Phase 13.1, a simple approach is acceptable: if multiple conflicts exist, the first one shown and resolved will update localStorage. Subsequent pulls for remaining keys may no longer conflict (if the coach hasn't changed them). If they do conflict, the next edit-triggered push will catch it via the normal 412 path.
**Warning signs:** Some sync keys silently overwriting local data while the conflict dialog is open for a different key.

### Pitfall 6: updatedAt Not Available in GET Response
**What goes wrong:** The ConflictDialog shows "Last saved: Unknown" for the cloud timestamp because the GET response doesn't include `updatedAt`.
**Why it happens:** The GET endpoints return `{ data, _etag }` but may not include `updatedAt`. The PUT response also only returns `{ data, _etag }`.
**How to avoid:** Check whether the API GET endpoints include `updatedAt` in their response. The Cosmos document has `updatedAt` as a field, but the API may only return `data` and `_etag`. If `updatedAt` is not available from the GET, pass `null` for `cloudUpdatedAt` in the ConflictInfo -- the dialog already handles this with "Unknown" fallback.
**Warning signs:** Cloud timestamp always showing "Unknown" in conflict dialog.

## Code Examples

### Modified pullFromCloud with Pull-Time Conflict Detection
```typescript
// Source: Application-specific extension of existing pullFromCloud in sync-engine.ts
export async function pullFromCloud(
  key: string,
  config: SyncKeyConfig,
  onStatus: (status: SyncStatus) => void,
  onConflict?: (info: ConflictInfo) => void,
): Promise<void> {
  if (pulledKeys.has(key)) {
    onStatus('synced');
    return;
  }

  if (dirtyKeys.has(key)) {
    onStatus('synced');
    return;
  }

  onStatus('syncing');

  try {
    const response = await fetch(config.endpoint, {
      method: 'GET',
      headers: { 'Content-Type': 'application/json' },
    });

    if (!response.ok) {
      if (response.status === 401) {
        onStatus('error');
        return;
      }
      onStatus('error');
      return;
    }

    const json = (await response.json()) as Record<string, unknown>;

    if (config.mode === 'singleton') {
      const cloudEtag = typeof json._etag === 'string' ? json._etag : null;
      const data = config.responseKey ? json[config.responseKey] : json.data;

      if (data !== null && data !== undefined) {
        if (typeof data === 'object' && !Array.isArray(data)
            && Object.keys(data as object).length === 0) {
          onStatus('synced');
          return;
        }

        // Pull-time conflict check: local offline edits vs. cloud data
        if (onConflict && hasNonDefaultData(key)) {
          const localRaw = localStorage.getItem(key);
          if (localRaw !== null) {
            try {
              const localData = JSON.parse(localRaw);
              if (JSON.stringify(localData) !== JSON.stringify(data)) {
                onConflict({
                  key,
                  localData,
                  cloudData: data,
                  cloudEtag,
                  cloudUpdatedAt: (json.updatedAt as string) ?? null,
                });
                pulledKeys.add(key);
                onStatus('error');
                return;
              }
            } catch {
              // Parse failure on local data — overwrite is safe
            }
          }
        }

        // No conflict — proceed with normal overwrite
        if (cloudEtag) {
          etagStore.set(key, cloudEtag);
        }
        localStorage.setItem(key, JSON.stringify(data));
        window.dispatchEvent(
          new CustomEvent('local-storage-sync', {
            detail: { key, value: data },
          })
        );
      }
    } else {
      // collection mode — unchanged
      // ...existing collection logic...
    }

    pulledKeys.add(key);
    onStatus('synced');
  } catch {
    onStatus('offline');
  }
}
```

### Modified useCloudStorage Pull Effect
```typescript
// Source: Application-specific modification to useCloudStorage.ts
// Pull from cloud on mount (authenticated only)
useEffect(() => {
  if (!user) return;
  pullFromCloud(
    key,
    apiConfigRef.current,
    (status) => reportStatus(key, status),
    onConflict,  // NEW: pass conflict handler to detect pull-time conflicts
  );
}, [key, user, reportStatus, onConflict]);
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| In-memory dirty flags only | Compare local vs. cloud data at pull time | Phase 13.1 | Catches conflicts across page reloads where in-memory flags are lost |
| Separate dialog for pull conflicts | Reuse existing ConflictDialog | Phase 13.1 | Single conflict resolution UX for all conflict sources |

**Deprecated/outdated:**
- Relying on in-memory flags (`dirtyKeys`) to survive auth redirects: Not possible; SWA auth uses full page redirects

## Open Questions

1. **Does the API GET response include `updatedAt` for the conflict dialog timestamp?**
   - What we know: The Cosmos document stores `updatedAt` (set on every PUT). The GET handler returns `{ data: resource.data, _etag: resource._etag }`.
   - What's unclear: Whether `resource.updatedAt` is included in the response or only `data` and `_etag`.
   - Recommendation: Check the actual GET response. If `updatedAt` is missing, either add it to the GET response body or accept "Unknown" in the dialog. Adding it to the GET is a minor API change (`jsonBody: { data: resource.data, _etag: resource._etag, updatedAt: resource.updatedAt }`).

2. **Should multiple simultaneous pull conflicts be queued?**
   - What we know: All 4 singleton keys pull simultaneously. If the coach has offline edits in multiple keys, multiple conflicts could fire.
   - What's unclear: Whether the current single-conflict state in SyncContext is sufficient.
   - Recommendation: For Phase 13.1, keep the single-conflict approach. In practice, it's unlikely a coach edits ALL 4 data types while logged out. If it does happen, the first conflict shown wins, and remaining keys get overwritten (or caught by subsequent push-time 412s). A conflict queue could be a follow-up enhancement if testing reveals issues.

3. **Should the conflict dialog message distinguish between "push conflict" and "pull conflict"?**
   - What we know: Current dialog says "Your data was changed on another device since your last sync."
   - What's unclear: Whether this message is accurate for the offline-to-online scenario (the cloud data may not have changed -- the LOCAL data changed while offline).
   - Recommendation: The message is slightly misleading for pull conflicts. Consider making it generic: "Your local data differs from the cloud version. Choose which to keep." However, changing the message is a minor UX polish that can be deferred. The current message is close enough to be functional.

## Sources

### Primary (HIGH confidence)
- **Codebase analysis** (all findings verified by reading actual source files):
  - `src/sync/sync-engine.ts` — pullFromCloud, pushToCloud, dirtyKeys, pulledKeys, etagStore, hasNonDefaultData
  - `src/sync/SyncContext.tsx` — SyncProvider, activeConflict state, resolveConflict, migration logic
  - `src/sync/useCloudStorage.ts` — Pull-on-mount effect, auth-gated sync behavior
  - `src/sync/ConflictDialog.tsx` — Existing dialog component
  - `src/auth/AuthContext.tsx` — Auth state fetching via /.auth/me
  - `src/components/app-shell/AppHeader.tsx` — Login/logout links (/.auth/login/aad, /.auth/logout)
  - `api/src/functions/roster.ts` — API ETag handling pattern (representative of all singleton endpoints)
  - `.planning/phases/13-sync-hardening/13-RESEARCH.md` — Phase 13 design decisions and patterns
  - `.planning/phases/13-sync-hardening/13-02-SUMMARY.md` — Phase 13 implementation summary

### Secondary (MEDIUM confidence)
- SWA auth redirect behavior: Known to be a full-page redirect (standard browser OAuth flow), verified by the `href="/.auth/login/aad"` pattern in AppHeader.tsx

### Tertiary (LOW confidence)
- None — all findings are directly from codebase analysis

## Metadata

**Confidence breakdown:**
- Root cause analysis: HIGH — Traced the exact execution flow through actual source code; every guard that fails is clearly identified
- Fix architecture: HIGH — Reuses existing patterns (onConflict callback, ConflictInfo type, ConflictDialog) with minimal new code
- Pitfalls: HIGH — Each pitfall identified from direct code reading (e.g., collection mode semantics, multiple-conflict race)
- Scope estimate: HIGH — Two files modified, no new files, no new dependencies

**Research date:** 2026-02-15
**Valid until:** 2026-03-15 (30 days — stable domain, fix is in application logic not library APIs)
