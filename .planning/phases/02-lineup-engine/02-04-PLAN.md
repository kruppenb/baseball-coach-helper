---
phase: 02-lineup-engine
plan: 04
type: execute
wave: 3
depends_on: ["02-01", "02-02", "02-03"]
files_modified:
  - src/hooks/useLineup.ts
  - src/components/lineup/LineupGrid.tsx
  - src/components/lineup/LineupGrid.module.css
  - src/components/lineup/ValidationPanel.tsx
  - src/components/lineup/ValidationPanel.module.css
autonomous: true

must_haves:
  truths:
    - "useLineup hook persists all lineup state (P/C assignments, blocks, generated lineups) in localStorage"
    - "Lineup grid shows positions as rows and innings as columns with player names in cells"
    - "Bench row shows which players sit each inning"
    - "Validation errors display with coach-friendly messages and player names"
    - "State survives tab switches (localStorage persistence via useLocalStorage)"
  artifacts:
    - path: "src/hooks/useLineup.ts"
      provides: "Central lineup state management hook"
      exports: ["useLineup"]
      min_lines: 60
    - path: "src/components/lineup/LineupGrid.tsx"
      provides: "CSS Grid display of lineup (positions x innings) with bench row"
      exports: ["LineupGrid"]
      min_lines: 40
    - path: "src/components/lineup/LineupGrid.module.css"
      provides: "Grid layout with position labels, inning headers, cells, bench row"
      min_lines: 30
    - path: "src/components/lineup/ValidationPanel.tsx"
      provides: "Validation error display with grouped coach-friendly messages"
      exports: ["ValidationPanel"]
      min_lines: 20
    - path: "src/components/lineup/ValidationPanel.module.css"
      provides: "Error panel styling with warning colors"
      min_lines: 10
  key_links:
    - from: "src/hooks/useLineup.ts"
      to: "src/logic/lineup-generator.ts"
      via: "calls generateMultipleLineups and preValidate"
      pattern: "import.*(generateMultipleLineups|preValidate).*from.*lineup-generator"
    - from: "src/hooks/useLineup.ts"
      to: "src/logic/lineup-validator.ts"
      via: "calls validateLineup for real-time validation"
      pattern: "import.*validateLineup.*from.*lineup-validator"
    - from: "src/hooks/useLineup.ts"
      to: "src/hooks/useLocalStorage.ts"
      via: "persists LineupState"
      pattern: "useLocalStorage.*lineupState"
    - from: "src/components/lineup/LineupGrid.tsx"
      to: "src/types/index.ts"
      via: "imports Lineup, Position, POSITIONS, Player"
      pattern: "import.*from.*types"
---

<objective>
Build the useLineup state management hook and the lineup display components (grid + validation panel).

Purpose: The hook is the bridge between pure logic (Plans 02-01/02-02) and the UI (Plan 02-03). It manages all lineup-related state in localStorage, exposes mutation functions, and orchestrates generation. The grid and validation panel are the output display that shows generated lineups and any constraint violations.

Output: useLineup.ts hook, LineupGrid.tsx (innings x positions grid with bench), ValidationPanel.tsx (error message list).
</objective>

<execution_context>
@C:/Users/nicho/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicho/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-lineup-engine/02-RESEARCH.md

# Dependencies from earlier plans
@src/types/index.ts
@src/logic/lineup-types.ts
@src/logic/lineup-generator.ts
@src/logic/lineup-validator.ts
@src/hooks/useLocalStorage.ts
@src/hooks/useRoster.ts
@src/hooks/useGameConfig.ts
@src/styles/tokens.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build useLineup hook with localStorage-backed state management</name>
  <files>src/hooks/useLineup.ts</files>
  <action>
    Create useLineup.ts following the pattern from 02-RESEARCH.md's useLineup example, with these specifics:

    **State shape (persisted in localStorage as 'lineupState'):**
    ```typescript
    const defaultState: LineupState = {
      pitcherAssignments: {},
      catcherAssignments: {},
      positionBlocks: {},
      generatedLineups: [],
      selectedLineupIndex: null,
    };
    ```

    **Hook dependencies:**
    - useLocalStorage<LineupState>('lineupState', defaultState) for persistence
    - useRoster() for players and presentCount
    - useGameConfig() for innings count

    **Exposed functions:**
    1. `setPitcher(inning: number, playerId: string)` -- updates pitcherAssignments[inning]. If playerId is '', delete that inning key (clearing assignment).
    2. `setCatcher(inning: number, playerId: string)` -- same pattern for catcherAssignments.
    3. `togglePositionBlock(playerId: string, position: Position)` -- if position is in positionBlocks[playerId], remove it; if not, add it. If player has no blocks, create the array.
    4. `generate(): { success: boolean; count: number; errors: string[] }` -- Converts BatteryAssignments (Record objects) into the format needed by generateMultipleLineups. Runs preValidate() first -- if errors, return { success: false, count: 0, errors }. Otherwise runs generateMultipleLineups(input, 3). Stores valid lineups in state.generatedLineups, sets selectedLineupIndex to 0 if any valid results. Returns success status.
    5. `selectLineup(index: number)` -- sets selectedLineupIndex.
    6. `clearLineups()` -- resets generatedLineups to [] and selectedLineupIndex to null. Does NOT clear P/C assignments or position blocks.

    **Exposed computed values:**
    - `presentPlayers`: filtered from useRoster().players where isPresent === true
    - `innings`: from useGameConfig().config.innings
    - `selectedLineup`: state.generatedLineups[state.selectedLineupIndex] or null
    - `validationErrors`: if selectedLineup exists, run validateLineup() on it; otherwise empty array
    - `preAssignmentErrors`: run a lightweight check for same-player P+C conflicts and absent-player assignments, returning string[] for inline display (not full preValidate -- just the real-time checks)

    **Important implementation details:**
    - BatteryAssignments is Record<number, string> (JSON-serializable). The generate() function must handle the conversion since generateMultipleLineups expects the same Record format (research showed Map but we should use Record to keep it JSON-serializable for localStorage).
    - Actually, check the types from 02-01. If GenerateLineupInput uses Record-based types (not Map), just pass directly. If it uses Map, convert at the boundary. Either way, the hook bridges the two.
    - When innings count changes (e.g., user switches from 6 to 5 on Game Setup), any P/C assignments for inning 6 become stale. The hook should clean up stale assignments when innings changes (remove any pitcherAssignments/catcherAssignments keys > innings).
    - validationErrors should be computed via useMemo to avoid re-running on every render. Memoize on [selectedLineup, presentPlayers, innings, state.pitcherAssignments, state.catcherAssignments, state.positionBlocks].

    **Do NOT:**
    - Import React components -- this is a hook
    - Use Map or Set for state (not JSON-serializable for localStorage)
    - Generate on every render -- generate() is called explicitly by user action
  </action>
  <verify>
    - `npm run build` passes with zero TypeScript errors
    - useLineup exports correctly
    - Hook uses useLocalStorage with key 'lineupState'
    - Hook imports from logic/ files (not reimplementing validation/generation)
    - Hook cleans up stale assignments when innings count would be reduced
  </verify>
  <done>useLineup hook persists all lineup state in localStorage, exposes P/C assignment, position block toggling, generation with pre-validation, lineup selection, and computed validation errors. State survives tab switches and page refreshes.</done>
</task>

<task type="auto">
  <name>Task 2: Build LineupGrid and ValidationPanel display components</name>
  <files>src/components/lineup/LineupGrid.tsx, src/components/lineup/LineupGrid.module.css, src/components/lineup/ValidationPanel.tsx, src/components/lineup/ValidationPanel.module.css</files>
  <action>
    **LineupGrid.tsx -- CSS Grid display of generated lineup:**

    Props interface:
    ```typescript
    interface LineupGridProps {
      lineup: Lineup;        // Record<number, InningAssignment>
      innings: number;
      players: Player[];     // for ID-to-name resolution
      errors: ValidationError[];  // for cell highlighting
    }
    ```

    Component structure:
    - CSS Grid container with `gridTemplateColumns: 'auto repeat(${innings}, 1fr)'`
    - Header row: empty corner cell + "Inn 1", "Inn 2", etc.
    - For each position in POSITIONS order (P, C, 1B, 2B, 3B, SS, LF, CF, RF):
      - Position label cell (e.g., "P", "1B")
      - For each inning: cell showing player name (resolved from lineup[inning][position] via players array)
      - If an error references this inning+position, add .errorCell class
    - Bench row: label "Bench", then for each inning list players who are present but not assigned to any position that inning (comma-separated names)
    - Helper function: getPlayerName(playerId: string) -> looks up in players array, returns name or '' if not found
    - Helper function: hasError(inning: number, position: Position) -> checks errors array for matching inning + position
    - If lineup is empty (no innings), show nothing or a placeholder

    **LineupGrid.module.css:**
    - .grid: display grid, border 1px solid --color-border, border-radius --radius-md, overflow hidden
    - .cornerCell: background --color-surface, padding --space-sm, font-weight 600, border-bottom + border-right 1px solid --color-border
    - .headerCell: background --color-surface, padding --space-sm, text-align center, font-weight 600, font-size --font-size-sm, border-bottom 1px solid --color-border. Not first: border-left.
    - .positionLabel: background --color-surface, padding --space-sm, font-weight 600, font-size --font-size-sm, border-bottom + border-right 1px solid --color-border
    - .cell: padding --space-sm, text-align center, font-size --font-size-sm, border-bottom 1px solid --color-border. Not first in row: border-left. Min-height --min-tap-size for readability.
    - .errorCell: background #fff3cd (soft yellow warning). Can also add a subtle left border-color --color-danger.
    - .benchCell: padding --space-sm, text-align center, font-size --font-size-sm, color --color-text-muted, font-style italic, border-bottom 1px solid --color-border. Not first: border-left.
    - .positionLabel for bench: font-style italic

    **ValidationPanel.tsx -- error message display:**

    Props interface:
    ```typescript
    interface ValidationPanelProps {
      errors: ValidationError[];
      preErrors: string[];  // pre-assignment conflicts (real-time)
    }
    ```

    Component structure:
    - If no errors and no preErrors, render nothing (return null)
    - If preErrors exist (pre-assignment conflicts), show them in a warning box:
      - Icon or prefix: "Warning" heading
      - List of preErrors as bullet points
    - If validation errors exist (post-generation), show them in an error box:
      - Heading: "Lineup Issues" or "Validation Errors"
      - List of error.message values as bullet points
      - Group by rule if multiple errors of same rule? No -- keep it flat and simple. Each error gets its own line.

    **ValidationPanel.module.css:**
    - .panel: margin-top --space-md
    - .warningBox: background #fff3cd, border 1px solid #ffc107, border-radius --radius-md, padding --space-md
    - .errorBox: background --color-blocked-bg (from tokens), border 1px solid --color-blocked, border-radius --radius-md, padding --space-md
    - .heading: font-weight 600, margin-bottom --space-sm, font-size --font-size-base
    - .list: list-style disc, padding-left --space-xl, display flex, flex-direction column, gap --space-xs
    - .listItem: font-size --font-size-sm, line-height 1.5

    **Do NOT:**
    - Call hooks in these components -- purely presentational (receive data via props)
    - Add interactive elements to the grid (it's display-only)
    - Truncate error messages -- show them in full
  </action>
  <verify>
    - `npm run build` passes with zero TypeScript errors
    - LineupGrid exports correctly and renders a CSS Grid
    - ValidationPanel exports correctly and conditionally renders
    - LineupGrid resolves player IDs to names
    - LineupGrid highlights cells with matching validation errors
    - ValidationPanel returns null when no errors
    - No hooks called in either component
  </verify>
  <done>LineupGrid renders a positions-by-innings grid with player names, bench row, and error highlighting. ValidationPanel shows pre-assignment warnings and post-generation validation errors in coach-friendly language. Both are purely presentational.</done>
</task>

</tasks>

<verification>
- `npm run build` passes with zero TypeScript errors
- useLineup hook persists state via useLocalStorage with 'lineupState' key
- LineupGrid correctly displays position labels, inning headers, player names, and bench row
- ValidationPanel conditionally renders only when errors exist
- All components follow Phase 1 CSS conventions (CSS Modules + custom properties)
- No circular dependencies between hooks and components
</verification>

<success_criteria>
- useLineup hook bridges logic layer (generator + validator) to UI layer
- All lineup state persists across tab switches and page refreshes via localStorage
- generate() runs preValidate first, then generateMultipleLineups, stores results
- LineupGrid displays the selected lineup as a clean positions x innings grid
- Bench players shown per inning
- ValidationPanel displays errors only when they exist
- Error highlighting on grid cells matches validation error locations
</success_criteria>

<output>
After completion, create `.planning/phases/02-lineup-engine/02-04-SUMMARY.md`
</output>
