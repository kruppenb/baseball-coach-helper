---
phase: 06-api-database
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - api/src/functions/roster.ts
  - api/src/functions/game-config.ts
  - api/src/functions/lineup-state.ts
  - api/src/functions/game-history.ts
  - api/src/functions/batting.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/roster returns the authenticated coach's roster (Player[]) or empty array if none saved"
    - "PUT /api/roster upserts the coach's roster under their userId partition"
    - "GET /api/game-config returns the coach's game config or default {innings: 6}"
    - "PUT /api/game-config upserts the coach's game config"
    - "GET /api/lineup-state returns the coach's lineup state or null"
    - "PUT /api/lineup-state upserts the coach's lineup state"
    - "GET /api/game-history returns all game history entries for the coach"
    - "PUT /api/game-history upserts a single game history entry as its own document"
    - "GET /api/batting returns both battingOrderState and battingHistory for the coach"
    - "PUT /api/batting upserts either battingOrderState or a battingHistory entry based on docType field"
    - "All endpoints return 401 when x-ms-client-principal header is missing"
    - "All endpoints scope data to the requesting coach's userId partition key"
  artifacts:
    - path: "api/src/functions/roster.ts"
      provides: "GET/PUT /api/roster endpoints"
      exports: ["getRoster", "putRoster"]
    - path: "api/src/functions/game-config.ts"
      provides: "GET/PUT /api/game-config endpoints"
      exports: ["getGameConfig", "putGameConfig"]
    - path: "api/src/functions/lineup-state.ts"
      provides: "GET/PUT /api/lineup-state endpoints"
      exports: ["getLineupState", "putLineupState"]
    - path: "api/src/functions/game-history.ts"
      provides: "GET/PUT /api/game-history endpoints"
      exports: ["getGameHistory", "putGameHistoryEntry"]
    - path: "api/src/functions/batting.ts"
      provides: "GET/PUT /api/batting endpoints"
      exports: ["getBatting", "putBatting"]
  key_links:
    - from: "api/src/functions/roster.ts"
      to: "api/src/lib/auth.ts"
      via: "import parseClientPrincipal"
      pattern: "parseClientPrincipal"
    - from: "api/src/functions/roster.ts"
      to: "api/src/lib/cosmos.ts"
      via: "import container"
      pattern: "container\\.item|container\\.items"
    - from: "api/src/functions/game-history.ts"
      to: "api/src/lib/cosmos.ts"
      via: "query for multiple documents by docType"
      pattern: "container\\.items\\.query"
    - from: "api/src/functions/batting.ts"
      to: "api/src/lib/cosmos.ts"
      via: "query for battingOrderState singleton + battingHistory collection"
      pattern: "container\\.items\\.query"
---

<objective>
Create all Azure Functions HTTP endpoints for coach data CRUD operations.

Purpose: Implements the 5 function files that expose GET/PUT endpoints for each data type (roster, game-config, lineup-state, game-history, batting). These endpoints use the shared auth and cosmos libraries from Plan 01 to authenticate requests and read/write Cosmos DB. After this plan, the entire server-side API is complete and buildable.

Output: 5 function files in api/src/functions/ that register 10 HTTP handlers (GET+PUT for each route), all using authLevel: 'anonymous' (SWA handles auth), all scoping data by userId partition key.
</objective>

<execution_context>
@C:/Users/nicho/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicho/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-api-database/06-RESEARCH.md
@.planning/phases/06-api-database/06-01-SUMMARY.md
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create singleton-document endpoints (roster, game-config, lineup-state)</name>
  <files>
    api/src/functions/roster.ts
    api/src/functions/game-config.ts
    api/src/functions/lineup-state.ts
  </files>
  <action>
Create three function files for data types that are stored as a single document per coach (singleton pattern). All three follow the same pattern -- only the route name, docType, and default empty value differ.

**Shared pattern for each file:**
- Import { app, HttpRequest, HttpResponseInit, InvocationContext } from '@azure/functions'
- Import { parseClientPrincipal } from '../lib/auth'
- Import { container } from '../lib/cosmos'
- authLevel: 'anonymous' on ALL registrations (SWA handles auth -- do NOT use 'function')

**GET handler pattern:**
1. Parse client principal; if null, return { status: 401, jsonBody: { error: 'Not authenticated' } }
2. Construct document ID as `{docType}-{principal.userId}` (deterministic -- no UUID needed for singletons)
3. Read from container: `container.item(docId, principal.userId).read()`
4. If resource is null/undefined, return { status: 200, jsonBody: { data: {defaultValue}, _etag: null } }
5. If resource exists, return { status: 200, jsonBody: { data: resource.data, _etag: resource._etag } }
6. Wrap Cosmos call in try/catch; on error, return { status: 500, jsonBody: { error: 'Internal server error' } } and log via context.error()

**PUT handler pattern:**
1. Parse client principal; if null, return 401
2. Parse request body via request.json() as { data: unknown }
3. Construct document: { id: `{docType}-{principal.userId}`, userId: principal.userId, docType, data: body.data, updatedAt: new Date().toISOString() }
4. Upsert: container.items.upsert(doc)
5. Return { status: 200, jsonBody: { data: resource.data, _etag: resource._etag } }
6. Wrap in try/catch with 500 error handling

**File specifics:**

roster.ts:
- route: 'roster'
- docType: 'roster'
- GET default: [] (empty array -- no players yet)
- Function names: getRoster, putRoster
- app.http registrations: 'getRoster' (GET, route: 'roster'), 'putRoster' (PUT, route: 'roster')

game-config.ts:
- route: 'game-config'
- docType: 'gameConfig'
- GET default: { innings: 6 } (matches frontend default in useGameConfig)
- Function names: getGameConfig, putGameConfig

lineup-state.ts:
- route: 'lineup-state'
- docType: 'lineupState'
- GET default: null (no lineup state until coach generates one)
- Function names: getLineupState, putLineupState
  </action>
  <verify>
Run: `cd C:/repos/baseball-coach-helper/api && npx tsc --noEmit` -- should compile with zero errors. Verify all three files exist. Check that each file imports from '../lib/auth' and '../lib/cosmos'. Check that authLevel is 'anonymous' in every app.http() call.
  </verify>
  <done>
Three function files exist at api/src/functions/{roster,game-config,lineup-state}.ts. Each registers GET and PUT handlers with authLevel 'anonymous'. GET returns coach's data scoped by userId or a sensible default. PUT upserts a document partitioned by userId. All compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create collection-document endpoints (game-history, batting)</name>
  <files>
    api/src/functions/game-history.ts
    api/src/functions/batting.ts
  </files>
  <action>
Create two function files for data types that involve multiple documents per coach (collection pattern). These use Cosmos queries instead of direct item reads.

**game-history.ts:**

GET handler (getGameHistory):
1. Parse client principal; if null, return 401
2. Query: SELECT * FROM c WHERE c.userId = @userId AND c.docType = @docType
   - Parameters: @userId = principal.userId, @docType = 'gameHistory'
3. Use container.items.query(querySpec).fetchAll()
4. Return { status: 200, jsonBody: { data: resources.map(r => r.data) } }
   - Returns an array of GameHistoryEntry objects (the frontend expects GameHistoryEntry[])
5. Wrap in try/catch with 500 error handling

PUT handler (putGameHistoryEntry):
1. Parse client principal; if null, return 401
2. Parse body as { data: { id: string, [key: string]: unknown } }
   - The `id` field is the game's UUID from the frontend (GameHistoryEntry.id)
3. Construct document: { id: `game-${principal.userId}-${body.data.id}`, userId: principal.userId, docType: 'gameHistory', data: body.data, updatedAt: new Date().toISOString() }
   - Compound ID ensures uniqueness per coach per game
4. Upsert: container.items.upsert(doc)
5. Return { status: 200, jsonBody: { data: resource.data, _etag: resource._etag } }

Registration: 'getGameHistory' (GET, route: 'game-history'), 'putGameHistoryEntry' (PUT, route: 'game-history')

**batting.ts:**

This endpoint handles both battingOrderState (singleton) and battingHistory (collection) via a single route.

GET handler (getBatting):
1. Parse client principal; if null, return 401
2. Read battingOrderState singleton: container.item(`battingOrderState-${principal.userId}`, principal.userId).read()
   - If not found, use default: { currentOrder: null, isConfirmed: false }
3. Query battingHistory collection: SELECT * FROM c WHERE c.userId = @userId AND c.docType = 'battingHistory'
4. Return { status: 200, jsonBody: { battingOrderState: orderResource?.data ?? { currentOrder: null, isConfirmed: false }, battingHistory: historyResources.map(r => r.data) } }
   - NOTE: This endpoint returns two fields instead of a single `data` field, because it combines two document types

PUT handler (putBatting):
1. Parse client principal; if null, return 401
2. Parse body as { docType: 'battingOrderState' | 'battingHistory', data: unknown }
3. If docType is 'battingOrderState':
   - Document ID: `battingOrderState-${principal.userId}` (singleton)
   - Upsert with docType 'battingOrderState'
4. If docType is 'battingHistory':
   - Extract id from body.data (BattingHistoryEntry.id)
   - Document ID: `batting-${principal.userId}-${(body.data as {id: string}).id}` (per-entry)
   - Upsert with docType 'battingHistory'
5. If docType is neither, return { status: 400, jsonBody: { error: 'Invalid docType. Expected battingOrderState or battingHistory' } }
6. Return upserted data with _etag

Registration: 'getBatting' (GET, route: 'batting'), 'putBatting' (PUT, route: 'batting')
  </action>
  <verify>
Run: `cd C:/repos/baseball-coach-helper/api && npx tsc --noEmit` -- zero errors. Then run `cd C:/repos/baseball-coach-helper/api && npm run build` -- should produce dist/functions/*.js files. Verify `ls api/dist/functions/` shows all 5 compiled function files. Check that game-history.ts uses container.items.query (not container.item) for GET.
  </verify>
  <done>
game-history.ts registers GET (query all game entries) and PUT (upsert single game entry) at route 'game-history'. batting.ts registers GET (returns both battingOrderState + battingHistory) and PUT (accepts docType discriminator for either type) at route 'batting'. Full API build succeeds and produces 5 JS files in api/dist/functions/. All 10 HTTP handlers use authLevel 'anonymous' and scope data by userId partition key.
  </done>
</task>

</tasks>

<verification>
1. `cd api && npm run build` succeeds with zero errors
2. `ls api/dist/functions/` shows roster.js, game-config.js, lineup-state.js, game-history.js, batting.js
3. Every function file imports parseClientPrincipal from '../lib/auth'
4. Every function file imports container from '../lib/cosmos'
5. Every app.http() registration uses authLevel: 'anonymous'
6. Every GET handler returns 401 when client principal is null
7. Every PUT handler scopes the document to principal.userId as partition key
8. game-history GET uses container.items.query for multiple documents
9. batting GET combines singleton read + collection query into one response
10. No Cosmos DB credentials appear in any function file (only imported from cosmos.ts which reads env var)
</verification>

<success_criteria>
- All 5 function files compile and produce JS output in api/dist/functions/
- 10 HTTP handlers registered: GET+PUT for roster, game-config, lineup-state, game-history, batting
- Every endpoint rejects unauthenticated requests with 401
- Every endpoint scopes data to userId partition (no cross-coach data leakage possible)
- Singleton-doc endpoints use deterministic IDs ({docType}-{userId})
- Collection-doc endpoints use compound IDs and query by docType filter
- batting endpoint handles both battingOrderState and battingHistory via docType discriminator
</success_criteria>

<output>
After completion, create `.planning/phases/06-api-database/06-02-SUMMARY.md`
</output>
